Okay, I changed my mind a bit on your last provided code's approach, and I need your help:

When an addition component is completed and updated in the self.main_df, it can sometimes have another multiplcation/division component that needs to be evaluated AFTER the first evaluation to ensure order of operations. The way I have the lever and parser set up, multiplication/division and addition/subtraction are done in different modules, thus I need a way to update the values of one with another and vice versa, when such a complex query exists.

Take the following for example:

Initial Complex Eval Statement:
| eval test3=header_2+1/3

Now, the parser does a great job in separating these already, allowing me to catch them separately and execute them very easily using the separated addition/subtraction and multiplication/division functions we built above. However, I have no current mechanism to substitute and join them for the proper, expected result. For instance, the above eval statement will produce the following, in the following order:

We first land in the multiplication/division section and Variable 'test3' FIRST became [1.0, '/', 3.0] and test3's column in the self.main_df was set to 0.333 as expected.

The next step, which lands in the addition/subtraction section, is presented with the following data that is technically correct, but needs replacement. For instance, this is what I receive:

['header_2', '+', 1.0, '/', 3.0]

But what I want is this, with the ... 1.0, '/', 3.0] part of the list replaced with it's current variable name, which was evaluated to be test3 in the very last-explained section above (aka, the multiplication/division section). This will ensure that the current result for 1/3, which is already been evaluated and results stored in the self.main_df under header_3 before. So basically, I want/expect this, instead of the very last list I show above:

['header_2', '+', 'test3']

^ This would ensure that the current multiplication/division and addition/subtraction functions you created above and that are in use now in the lexer always consume previous steps completed evaluation when it comes to mathematical expressions.

To help achieve this, each time my program utilizes the calculate_expression for either multiplication/division and/or addition/subtraction, it creates an entry in the self.variables OrderedDict(), with the variable name as a key and the original query at that point as a value. The idea is that you we can pull from self.variables and perform replacements on the target expression BEFORE the next mathematical operation is actually evaluated, ensuring that previous calculations made are kept and updated properly. For instance, the original query above would produce the following entry in said self.variables for this specific situation that would be present JUST before the addition/subtraction part was to be executed:

OrderedDict([('test3', [1.0, '/', 3.0])])

Can you create a function that replaces any values parts of the self.variables OrderedDict() with the key (aka recently named variable name) within a given expression?

So for instance, given the above as situational input, I expect the following output to be ready for processing:

['header_2', '+', 'test3']

^^ This ensures that all calculations results are captured and within the proper order of operations.