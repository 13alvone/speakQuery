# Generated from lexers/tradeQuery.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,94,971,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,1,0,1,0,1,1,3,1,76,8,1,1,1,1,1,1,1,1,1,
        1,1,1,1,3,1,84,8,1,1,1,5,1,87,8,1,10,1,12,1,90,9,1,1,1,1,1,1,1,3,
        1,95,8,1,1,1,5,1,98,8,1,10,1,12,1,101,9,1,3,1,103,8,1,1,1,1,1,5,
        1,107,8,1,10,1,12,1,110,9,1,1,1,1,1,1,1,1,1,1,1,3,1,117,8,1,1,1,
        1,1,1,1,3,1,122,8,1,1,1,1,1,1,1,1,1,1,1,3,1,129,8,1,1,2,1,2,1,2,
        1,2,1,2,1,2,1,2,5,2,138,8,2,10,2,12,2,141,9,2,1,3,1,3,1,3,3,3,146,
        8,3,1,3,5,3,149,8,3,10,3,12,3,152,9,3,1,3,1,3,1,3,1,3,3,3,158,8,
        3,1,3,1,3,1,3,3,3,163,8,3,1,3,1,3,3,3,167,8,3,1,3,1,3,1,3,5,3,172,
        8,3,10,3,12,3,175,9,3,1,3,1,3,1,3,1,3,3,3,181,8,3,1,3,3,3,184,8,
        3,1,3,1,3,1,3,3,3,189,8,3,5,3,191,8,3,10,3,12,3,194,9,3,1,3,3,3,
        197,8,3,1,3,1,3,4,3,201,8,3,11,3,12,3,202,3,3,205,8,3,1,3,1,3,1,
        3,1,3,1,3,3,3,212,8,3,1,3,1,3,1,3,1,3,5,3,218,8,3,10,3,12,3,221,
        9,3,1,3,1,3,1,3,3,3,226,8,3,1,3,1,3,1,3,3,3,231,8,3,5,3,233,8,3,
        10,3,12,3,236,9,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,259,8,3,1,4,1,4,1,4,3,
        4,264,8,4,1,5,1,5,3,5,268,8,5,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,
        6,5,6,279,8,6,10,6,12,6,282,9,6,3,6,284,8,6,1,7,1,7,1,7,1,7,1,7,
        1,7,3,7,292,8,7,1,7,1,7,1,7,1,7,3,7,298,8,7,4,7,300,8,7,11,7,12,
        7,301,5,7,304,8,7,10,7,12,7,307,9,7,1,8,1,8,1,8,1,8,1,8,1,8,3,8,
        315,8,8,1,9,1,9,1,9,1,9,1,9,1,9,3,9,323,8,9,1,10,1,10,1,10,1,10,
        1,10,1,10,3,10,331,8,10,1,10,1,10,1,10,1,10,5,10,337,8,10,10,10,
        12,10,340,9,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,350,
        8,11,4,11,352,8,11,11,11,12,11,353,1,11,3,11,357,8,11,1,12,1,12,
        1,12,1,12,1,12,1,12,3,12,365,8,12,1,12,1,12,1,12,5,12,370,8,12,10,
        12,12,12,373,9,12,1,13,1,13,1,13,1,13,1,13,1,13,3,13,381,8,13,1,
        14,1,14,3,14,385,8,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,
        15,5,15,396,8,15,10,15,12,15,399,9,15,3,15,401,8,15,1,16,1,16,1,
        16,1,16,1,16,1,16,1,16,1,16,3,16,411,8,16,3,16,413,8,16,1,17,1,17,
        1,17,1,17,1,17,1,17,3,17,421,8,17,1,17,1,17,1,17,1,17,3,17,427,8,
        17,4,17,429,8,17,11,17,12,17,430,5,17,433,8,17,10,17,12,17,436,9,
        17,1,18,1,18,1,18,1,18,1,18,1,18,3,18,444,8,18,1,18,1,18,1,18,5,
        18,449,8,18,10,18,12,18,452,9,18,1,19,1,19,1,19,1,19,1,19,1,19,3,
        19,460,8,19,1,20,1,20,1,20,1,20,1,20,1,20,3,20,468,8,20,1,21,1,21,
        1,22,1,22,1,22,1,22,1,22,3,22,477,8,22,1,23,1,23,1,23,1,23,1,23,
        1,23,1,23,3,23,486,8,23,1,24,1,24,1,25,1,25,1,26,1,26,1,27,1,27,
        1,27,1,27,4,27,498,8,27,11,27,12,27,499,1,27,1,27,1,28,1,28,1,28,
        1,28,4,28,508,8,28,11,28,12,28,509,1,28,1,28,1,29,1,29,1,30,1,30,
        1,31,1,31,1,32,1,32,1,32,3,32,523,8,32,1,33,1,33,1,33,1,33,3,33,
        529,8,33,1,33,1,33,1,33,3,33,534,8,33,1,33,1,33,1,33,1,33,1,33,1,
        33,3,33,542,8,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,550,8,33,1,33,
        1,33,1,33,1,33,1,33,1,33,3,33,558,8,33,1,33,1,33,1,33,1,33,1,33,
        1,33,3,33,566,8,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,574,8,33,1,
        33,1,33,1,33,1,33,1,33,1,33,3,33,582,8,33,1,33,1,33,1,33,1,33,1,
        33,1,33,3,33,590,8,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,598,8,33,
        1,33,1,33,1,33,1,33,1,33,1,33,3,33,606,8,33,1,33,1,33,1,33,3,33,
        611,8,33,3,33,613,8,33,3,33,615,8,33,1,33,1,33,1,33,1,33,1,33,3,
        33,622,8,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,630,8,33,1,33,1,33,
        3,33,634,8,33,1,34,1,34,1,34,1,34,3,34,640,8,34,1,34,1,34,1,34,3,
        34,645,8,34,5,34,647,8,34,10,34,12,34,650,9,34,1,34,1,34,1,34,1,
        34,1,34,1,34,3,34,658,8,34,1,34,1,34,1,34,3,34,663,8,34,1,34,1,34,
        1,34,3,34,668,8,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,676,8,34,1,
        34,1,34,1,34,1,34,1,34,1,34,3,34,684,8,34,1,34,1,34,1,34,1,34,1,
        34,1,34,3,34,692,8,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,700,8,34,
        1,34,1,34,1,34,3,34,705,8,34,3,34,707,8,34,1,34,1,34,1,34,1,34,1,
        34,1,34,3,34,715,8,34,1,34,1,34,1,34,3,34,720,8,34,3,34,722,8,34,
        1,34,1,34,1,34,1,34,1,34,1,34,3,34,730,8,34,1,34,1,34,1,34,3,34,
        735,8,34,3,34,737,8,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,745,8,
        34,1,34,1,34,1,34,3,34,750,8,34,1,34,1,34,1,34,3,34,755,8,34,3,34,
        757,8,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,765,8,34,1,34,1,34,1,
        34,1,34,1,34,1,34,3,34,773,8,34,1,34,1,34,1,34,1,34,1,34,1,34,3,
        34,781,8,34,1,34,1,34,1,34,3,34,786,8,34,1,34,1,34,1,34,1,34,1,34,
        1,34,3,34,794,8,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,802,8,34,1,
        34,1,34,1,34,1,34,1,34,1,34,3,34,810,8,34,1,34,1,34,1,34,1,34,1,
        34,1,34,3,34,818,8,34,1,34,1,34,3,34,822,8,34,1,35,1,35,1,35,1,35,
        1,35,1,35,1,35,3,35,831,8,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,
        839,8,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,847,8,35,1,35,1,35,1,
        35,1,35,1,35,1,35,3,35,855,8,35,1,35,1,35,1,35,3,35,860,8,35,1,35,
        1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,873,8,35,
        1,35,1,35,1,35,3,35,878,8,35,4,35,880,8,35,11,35,12,35,881,1,35,
        1,35,1,35,1,35,1,35,1,35,3,35,890,8,35,1,35,1,35,1,35,3,35,895,8,
        35,4,35,897,8,35,11,35,12,35,898,1,35,1,35,1,35,1,35,1,35,1,35,3,
        35,907,8,35,1,35,1,35,1,35,3,35,912,8,35,1,35,1,35,1,35,1,35,1,35,
        1,35,3,35,920,8,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,
        930,8,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,938,8,35,1,35,1,35,1,
        35,1,35,1,35,1,35,3,35,946,8,35,1,35,1,35,1,35,1,35,1,35,1,35,3,
        35,954,8,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,962,8,35,1,35,1,35,
        1,35,1,35,1,35,3,35,969,8,35,1,35,0,5,14,20,24,34,36,36,0,2,4,6,
        8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
        52,54,56,58,60,62,64,66,68,70,0,7,2,0,23,23,30,30,1,0,86,87,1,0,
        88,89,1,0,90,92,1,0,71,72,1,0,80,85,1,0,66,67,1134,0,72,1,0,0,0,
        2,75,1,0,0,0,4,130,1,0,0,0,6,258,1,0,0,0,8,263,1,0,0,0,10,267,1,
        0,0,0,12,283,1,0,0,0,14,291,1,0,0,0,16,314,1,0,0,0,18,322,1,0,0,
        0,20,330,1,0,0,0,22,356,1,0,0,0,24,364,1,0,0,0,26,380,1,0,0,0,28,
        384,1,0,0,0,30,400,1,0,0,0,32,412,1,0,0,0,34,420,1,0,0,0,36,443,
        1,0,0,0,38,459,1,0,0,0,40,467,1,0,0,0,42,469,1,0,0,0,44,476,1,0,
        0,0,46,485,1,0,0,0,48,487,1,0,0,0,50,489,1,0,0,0,52,491,1,0,0,0,
        54,493,1,0,0,0,56,503,1,0,0,0,58,513,1,0,0,0,60,515,1,0,0,0,62,517,
        1,0,0,0,64,522,1,0,0,0,66,633,1,0,0,0,68,821,1,0,0,0,70,968,1,0,
        0,0,72,73,3,2,1,0,73,1,1,0,0,0,74,76,5,93,0,0,75,74,1,0,0,0,75,76,
        1,0,0,0,76,77,1,0,0,0,77,78,5,1,0,0,78,79,5,3,0,0,79,80,5,14,0,0,
        80,81,5,79,0,0,81,88,3,52,26,0,82,84,5,77,0,0,83,82,1,0,0,0,83,84,
        1,0,0,0,84,85,1,0,0,0,85,87,3,52,26,0,86,83,1,0,0,0,87,90,1,0,0,
        0,88,86,1,0,0,0,88,89,1,0,0,0,89,102,1,0,0,0,90,88,1,0,0,0,91,92,
        5,21,0,0,92,99,3,30,15,0,93,95,5,77,0,0,94,93,1,0,0,0,94,95,1,0,
        0,0,95,96,1,0,0,0,96,98,3,30,15,0,97,94,1,0,0,0,98,101,1,0,0,0,99,
        97,1,0,0,0,99,100,1,0,0,0,100,103,1,0,0,0,101,99,1,0,0,0,102,91,
        1,0,0,0,102,103,1,0,0,0,103,104,1,0,0,0,104,108,5,93,0,0,105,107,
        3,4,2,0,106,105,1,0,0,0,107,110,1,0,0,0,108,106,1,0,0,0,108,109,
        1,0,0,0,109,128,1,0,0,0,110,108,1,0,0,0,111,112,5,1,0,0,112,113,
        5,8,0,0,113,116,5,75,0,0,114,117,3,28,14,0,115,117,3,64,32,0,116,
        114,1,0,0,0,116,115,1,0,0,0,117,118,1,0,0,0,118,121,5,77,0,0,119,
        122,3,28,14,0,120,122,3,58,29,0,121,119,1,0,0,0,121,120,1,0,0,0,
        122,123,1,0,0,0,123,124,5,77,0,0,124,125,3,58,29,0,125,126,5,76,
        0,0,126,127,5,93,0,0,127,129,1,0,0,0,128,111,1,0,0,0,128,129,1,0,
        0,0,129,3,1,0,0,0,130,131,5,1,0,0,131,132,3,6,3,0,132,139,5,93,0,
        0,133,134,5,1,0,0,134,135,3,6,3,0,135,136,5,93,0,0,136,138,1,0,0,
        0,137,133,1,0,0,0,138,141,1,0,0,0,139,137,1,0,0,0,139,140,1,0,0,
        0,140,5,1,0,0,0,141,139,1,0,0,0,142,143,5,26,0,0,143,150,3,30,15,
        0,144,146,5,77,0,0,145,144,1,0,0,0,145,146,1,0,0,0,146,147,1,0,0,
        0,147,149,3,30,15,0,148,145,1,0,0,0,149,152,1,0,0,0,150,148,1,0,
        0,0,150,151,1,0,0,0,151,259,1,0,0,0,152,150,1,0,0,0,153,259,7,0,
        0,0,154,157,5,16,0,0,155,158,3,52,26,0,156,158,3,58,29,0,157,155,
        1,0,0,0,157,156,1,0,0,0,158,159,1,0,0,0,159,160,5,79,0,0,160,173,
        3,8,4,0,161,163,5,77,0,0,162,161,1,0,0,0,162,163,1,0,0,0,163,166,
        1,0,0,0,164,167,3,52,26,0,165,167,3,58,29,0,166,164,1,0,0,0,166,
        165,1,0,0,0,167,168,1,0,0,0,168,169,5,79,0,0,169,170,3,8,4,0,170,
        172,1,0,0,0,171,162,1,0,0,0,172,175,1,0,0,0,173,171,1,0,0,0,173,
        174,1,0,0,0,174,259,1,0,0,0,175,173,1,0,0,0,176,177,5,17,0,0,177,
        180,3,64,32,0,178,179,5,20,0,0,179,181,3,42,21,0,180,178,1,0,0,0,
        180,181,1,0,0,0,181,192,1,0,0,0,182,184,5,77,0,0,183,182,1,0,0,0,
        183,184,1,0,0,0,184,185,1,0,0,0,185,188,3,64,32,0,186,187,5,20,0,
        0,187,189,3,42,21,0,188,186,1,0,0,0,188,189,1,0,0,0,189,191,1,0,
        0,0,190,183,1,0,0,0,191,194,1,0,0,0,192,190,1,0,0,0,192,193,1,0,
        0,0,193,204,1,0,0,0,194,192,1,0,0,0,195,197,5,42,0,0,196,195,1,0,
        0,0,196,197,1,0,0,0,197,198,1,0,0,0,198,200,5,19,0,0,199,201,3,58,
        29,0,200,199,1,0,0,0,201,202,1,0,0,0,202,200,1,0,0,0,202,203,1,0,
        0,0,203,205,1,0,0,0,204,196,1,0,0,0,204,205,1,0,0,0,205,259,1,0,
        0,0,206,207,5,22,0,0,207,208,3,58,29,0,208,209,5,20,0,0,209,219,
        3,10,5,0,210,212,5,77,0,0,211,210,1,0,0,0,211,212,1,0,0,0,212,213,
        1,0,0,0,213,214,3,58,29,0,214,215,5,20,0,0,215,216,3,42,21,0,216,
        218,1,0,0,0,217,211,1,0,0,0,218,221,1,0,0,0,219,217,1,0,0,0,219,
        220,1,0,0,0,220,259,1,0,0,0,221,219,1,0,0,0,222,223,5,25,0,0,223,
        234,3,58,29,0,224,226,5,77,0,0,225,224,1,0,0,0,225,226,1,0,0,0,226,
        227,1,0,0,0,227,230,3,58,29,0,228,229,5,20,0,0,229,231,3,42,21,0,
        230,228,1,0,0,0,230,231,1,0,0,0,231,233,1,0,0,0,232,225,1,0,0,0,
        233,236,1,0,0,0,234,232,1,0,0,0,234,235,1,0,0,0,235,259,1,0,0,0,
        236,234,1,0,0,0,237,238,5,27,0,0,238,259,3,44,22,0,239,240,5,28,
        0,0,240,241,5,24,0,0,241,242,5,79,0,0,242,243,3,58,29,0,243,244,
        3,52,26,0,244,259,1,0,0,0,245,246,5,29,0,0,246,247,3,58,29,0,247,
        248,5,79,0,0,248,249,3,52,26,0,249,259,1,0,0,0,250,259,3,66,33,0,
        251,259,3,68,34,0,252,259,3,70,35,0,253,254,5,59,0,0,254,255,5,73,
        0,0,255,256,3,2,1,0,256,257,5,74,0,0,257,259,1,0,0,0,258,142,1,0,
        0,0,258,153,1,0,0,0,258,154,1,0,0,0,258,176,1,0,0,0,258,206,1,0,
        0,0,258,222,1,0,0,0,258,237,1,0,0,0,258,239,1,0,0,0,258,245,1,0,
        0,0,258,250,1,0,0,0,258,251,1,0,0,0,258,252,1,0,0,0,258,253,1,0,
        0,0,259,7,1,0,0,0,260,264,3,18,9,0,261,264,3,10,5,0,262,264,3,28,
        14,0,263,260,1,0,0,0,263,261,1,0,0,0,263,262,1,0,0,0,264,9,1,0,0,
        0,265,268,3,68,34,0,266,268,3,12,6,0,267,265,1,0,0,0,267,266,1,0,
        0,0,268,11,1,0,0,0,269,270,5,75,0,0,270,271,3,12,6,0,271,272,5,76,
        0,0,272,284,1,0,0,0,273,280,3,14,7,0,274,275,5,66,0,0,275,279,3,
        14,7,0,276,277,5,67,0,0,277,279,3,14,7,0,278,274,1,0,0,0,278,276,
        1,0,0,0,279,282,1,0,0,0,280,278,1,0,0,0,280,281,1,0,0,0,281,284,
        1,0,0,0,282,280,1,0,0,0,283,269,1,0,0,0,283,273,1,0,0,0,284,13,1,
        0,0,0,285,286,6,7,-1,0,286,287,5,75,0,0,287,288,3,14,7,0,288,289,
        5,76,0,0,289,292,1,0,0,0,290,292,3,16,8,0,291,285,1,0,0,0,291,290,
        1,0,0,0,292,305,1,0,0,0,293,299,10,2,0,0,294,297,5,86,0,0,295,298,
        3,16,8,0,296,298,3,14,7,0,297,295,1,0,0,0,297,296,1,0,0,0,298,300,
        1,0,0,0,299,294,1,0,0,0,300,301,1,0,0,0,301,299,1,0,0,0,301,302,
        1,0,0,0,302,304,1,0,0,0,303,293,1,0,0,0,304,307,1,0,0,0,305,303,
        1,0,0,0,305,306,1,0,0,0,306,15,1,0,0,0,307,305,1,0,0,0,308,315,3,
        54,27,0,309,310,5,75,0,0,310,311,3,10,5,0,311,312,5,76,0,0,312,315,
        1,0,0,0,313,315,3,40,20,0,314,308,1,0,0,0,314,309,1,0,0,0,314,313,
        1,0,0,0,315,17,1,0,0,0,316,317,5,75,0,0,317,318,3,18,9,0,318,319,
        5,76,0,0,319,323,1,0,0,0,320,323,3,66,33,0,321,323,3,20,10,0,322,
        316,1,0,0,0,322,320,1,0,0,0,322,321,1,0,0,0,323,19,1,0,0,0,324,325,
        6,10,-1,0,325,326,5,75,0,0,326,327,3,20,10,0,327,328,5,76,0,0,328,
        331,1,0,0,0,329,331,3,22,11,0,330,324,1,0,0,0,330,329,1,0,0,0,331,
        338,1,0,0,0,332,333,10,2,0,0,333,334,3,60,30,0,334,335,3,22,11,0,
        335,337,1,0,0,0,336,332,1,0,0,0,337,340,1,0,0,0,338,336,1,0,0,0,
        338,339,1,0,0,0,339,21,1,0,0,0,340,338,1,0,0,0,341,342,5,75,0,0,
        342,343,3,22,11,0,343,344,5,76,0,0,344,357,1,0,0,0,345,351,3,34,
        17,0,346,349,7,1,0,0,347,350,3,24,12,0,348,350,3,34,17,0,349,347,
        1,0,0,0,349,348,1,0,0,0,350,352,1,0,0,0,351,346,1,0,0,0,352,353,
        1,0,0,0,353,351,1,0,0,0,353,354,1,0,0,0,354,357,1,0,0,0,355,357,
        3,24,12,0,356,341,1,0,0,0,356,345,1,0,0,0,356,355,1,0,0,0,357,23,
        1,0,0,0,358,359,6,12,-1,0,359,360,5,75,0,0,360,361,3,24,12,0,361,
        362,5,76,0,0,362,365,1,0,0,0,363,365,3,26,13,0,364,358,1,0,0,0,364,
        363,1,0,0,0,365,371,1,0,0,0,366,367,10,2,0,0,367,368,7,2,0,0,368,
        370,3,26,13,0,369,366,1,0,0,0,370,373,1,0,0,0,371,369,1,0,0,0,371,
        372,1,0,0,0,372,25,1,0,0,0,373,371,1,0,0,0,374,381,3,56,28,0,375,
        376,5,75,0,0,376,377,3,18,9,0,377,378,5,76,0,0,378,381,1,0,0,0,379,
        381,3,44,22,0,380,374,1,0,0,0,380,375,1,0,0,0,380,379,1,0,0,0,381,
        27,1,0,0,0,382,385,3,64,32,0,383,385,3,30,15,0,384,382,1,0,0,0,384,
        383,1,0,0,0,385,29,1,0,0,0,386,387,5,75,0,0,387,388,3,30,15,0,388,
        389,5,76,0,0,389,401,1,0,0,0,390,397,3,32,16,0,391,392,5,66,0,0,
        392,396,3,32,16,0,393,394,5,67,0,0,394,396,3,32,16,0,395,391,1,0,
        0,0,395,393,1,0,0,0,396,399,1,0,0,0,397,395,1,0,0,0,397,398,1,0,
        0,0,398,401,1,0,0,0,399,397,1,0,0,0,400,386,1,0,0,0,400,390,1,0,
        0,0,401,31,1,0,0,0,402,403,5,75,0,0,403,404,3,32,16,0,404,405,5,
        76,0,0,405,413,1,0,0,0,406,410,3,34,17,0,407,408,3,60,30,0,408,409,
        3,34,17,0,409,411,1,0,0,0,410,407,1,0,0,0,410,411,1,0,0,0,411,413,
        1,0,0,0,412,402,1,0,0,0,412,406,1,0,0,0,413,33,1,0,0,0,414,415,6,
        17,-1,0,415,416,5,75,0,0,416,417,3,34,17,0,417,418,5,76,0,0,418,
        421,1,0,0,0,419,421,3,36,18,0,420,414,1,0,0,0,420,419,1,0,0,0,421,
        434,1,0,0,0,422,428,10,2,0,0,423,426,7,1,0,0,424,427,3,36,18,0,425,
        427,3,34,17,0,426,424,1,0,0,0,426,425,1,0,0,0,427,429,1,0,0,0,428,
        423,1,0,0,0,429,430,1,0,0,0,430,428,1,0,0,0,430,431,1,0,0,0,431,
        433,1,0,0,0,432,422,1,0,0,0,433,436,1,0,0,0,434,432,1,0,0,0,434,
        435,1,0,0,0,435,35,1,0,0,0,436,434,1,0,0,0,437,438,6,18,-1,0,438,
        439,5,75,0,0,439,440,3,36,18,0,440,441,5,76,0,0,441,444,1,0,0,0,
        442,444,3,38,19,0,443,437,1,0,0,0,443,442,1,0,0,0,444,450,1,0,0,
        0,445,446,10,2,0,0,446,447,7,2,0,0,447,449,3,38,19,0,448,445,1,0,
        0,0,449,452,1,0,0,0,450,448,1,0,0,0,450,451,1,0,0,0,451,37,1,0,0,
        0,452,450,1,0,0,0,453,460,3,54,27,0,454,455,5,75,0,0,455,456,3,28,
        14,0,456,457,5,76,0,0,457,460,1,0,0,0,458,460,3,40,20,0,459,453,
        1,0,0,0,459,454,1,0,0,0,459,458,1,0,0,0,460,39,1,0,0,0,461,468,3,
        46,23,0,462,468,3,64,32,0,463,468,3,48,24,0,464,468,3,50,25,0,465,
        468,3,52,26,0,466,468,3,58,29,0,467,461,1,0,0,0,467,462,1,0,0,0,
        467,463,1,0,0,0,467,464,1,0,0,0,467,465,1,0,0,0,467,466,1,0,0,0,
        468,41,1,0,0,0,469,470,3,52,26,0,470,43,1,0,0,0,471,477,3,46,23,
        0,472,477,3,66,33,0,473,477,3,48,24,0,474,477,5,72,0,0,475,477,3,
        58,29,0,476,471,1,0,0,0,476,472,1,0,0,0,476,473,1,0,0,0,476,474,
        1,0,0,0,476,475,1,0,0,0,477,45,1,0,0,0,478,479,3,48,24,0,479,480,
        7,3,0,0,480,486,1,0,0,0,481,482,7,3,0,0,482,486,3,48,24,0,483,484,
        5,87,0,0,484,486,3,48,24,0,485,478,1,0,0,0,485,481,1,0,0,0,485,483,
        1,0,0,0,486,47,1,0,0,0,487,488,5,69,0,0,488,49,1,0,0,0,489,490,7,
        4,0,0,490,51,1,0,0,0,491,492,5,70,0,0,492,53,1,0,0,0,493,494,5,73,
        0,0,494,497,3,28,14,0,495,496,5,77,0,0,496,498,3,28,14,0,497,495,
        1,0,0,0,498,499,1,0,0,0,499,497,1,0,0,0,499,500,1,0,0,0,500,501,
        1,0,0,0,501,502,5,74,0,0,502,55,1,0,0,0,503,504,5,73,0,0,504,507,
        3,18,9,0,505,506,5,77,0,0,506,508,3,18,9,0,507,505,1,0,0,0,508,509,
        1,0,0,0,509,507,1,0,0,0,509,510,1,0,0,0,510,511,1,0,0,0,511,512,
        5,74,0,0,512,57,1,0,0,0,513,514,5,68,0,0,514,59,1,0,0,0,515,516,
        7,5,0,0,516,61,1,0,0,0,517,518,7,6,0,0,518,63,1,0,0,0,519,523,3,
        66,33,0,520,523,3,68,34,0,521,523,3,70,35,0,522,519,1,0,0,0,522,
        520,1,0,0,0,522,521,1,0,0,0,523,65,1,0,0,0,524,525,5,32,0,0,525,
        528,5,75,0,0,526,529,3,18,9,0,527,529,3,66,33,0,528,526,1,0,0,0,
        528,527,1,0,0,0,529,530,1,0,0,0,530,533,5,77,0,0,531,534,3,18,9,
        0,532,534,3,66,33,0,533,531,1,0,0,0,533,532,1,0,0,0,534,535,1,0,
        0,0,535,536,5,76,0,0,536,634,1,0,0,0,537,538,5,33,0,0,538,541,5,
        75,0,0,539,542,3,18,9,0,540,542,3,66,33,0,541,539,1,0,0,0,541,540,
        1,0,0,0,542,543,1,0,0,0,543,544,5,76,0,0,544,634,1,0,0,0,545,546,
        5,34,0,0,546,549,5,75,0,0,547,550,3,18,9,0,548,550,3,66,33,0,549,
        547,1,0,0,0,549,548,1,0,0,0,550,551,1,0,0,0,551,552,5,76,0,0,552,
        634,1,0,0,0,553,554,5,37,0,0,554,557,5,75,0,0,555,558,3,18,9,0,556,
        558,3,66,33,0,557,555,1,0,0,0,557,556,1,0,0,0,558,559,1,0,0,0,559,
        560,5,76,0,0,560,634,1,0,0,0,561,562,5,38,0,0,562,565,5,75,0,0,563,
        566,3,18,9,0,564,566,3,66,33,0,565,563,1,0,0,0,565,564,1,0,0,0,566,
        567,1,0,0,0,567,568,5,76,0,0,568,634,1,0,0,0,569,570,5,41,0,0,570,
        573,5,75,0,0,571,574,3,18,9,0,572,574,3,66,33,0,573,571,1,0,0,0,
        573,572,1,0,0,0,574,575,1,0,0,0,575,576,5,76,0,0,576,634,1,0,0,0,
        577,578,5,35,0,0,578,581,5,75,0,0,579,582,3,18,9,0,580,582,3,66,
        33,0,581,579,1,0,0,0,581,580,1,0,0,0,582,583,1,0,0,0,583,584,5,76,
        0,0,584,634,1,0,0,0,585,586,5,36,0,0,586,589,5,75,0,0,587,590,3,
        18,9,0,588,590,3,66,33,0,589,587,1,0,0,0,589,588,1,0,0,0,590,591,
        1,0,0,0,591,592,5,76,0,0,592,634,1,0,0,0,593,594,5,40,0,0,594,597,
        5,75,0,0,595,598,3,18,9,0,596,598,3,66,33,0,597,595,1,0,0,0,597,
        596,1,0,0,0,598,599,1,0,0,0,599,600,5,76,0,0,600,634,1,0,0,0,601,
        602,5,39,0,0,602,614,5,75,0,0,603,606,3,18,9,0,604,606,3,66,33,0,
        605,603,1,0,0,0,605,604,1,0,0,0,606,612,1,0,0,0,607,610,5,77,0,0,
        608,611,3,18,9,0,609,611,3,66,33,0,610,608,1,0,0,0,610,609,1,0,0,
        0,611,613,1,0,0,0,612,607,1,0,0,0,612,613,1,0,0,0,613,615,1,0,0,
        0,614,605,1,0,0,0,614,615,1,0,0,0,615,616,1,0,0,0,616,634,5,76,0,
        0,617,618,5,44,0,0,618,621,5,75,0,0,619,622,3,18,9,0,620,622,3,66,
        33,0,621,619,1,0,0,0,621,620,1,0,0,0,622,623,1,0,0,0,623,624,5,76,
        0,0,624,634,1,0,0,0,625,626,5,43,0,0,626,629,5,75,0,0,627,630,3,
        18,9,0,628,630,3,66,33,0,629,627,1,0,0,0,629,628,1,0,0,0,630,631,
        1,0,0,0,631,632,5,76,0,0,632,634,1,0,0,0,633,524,1,0,0,0,633,537,
        1,0,0,0,633,545,1,0,0,0,633,553,1,0,0,0,633,561,1,0,0,0,633,569,
        1,0,0,0,633,577,1,0,0,0,633,585,1,0,0,0,633,593,1,0,0,0,633,601,
        1,0,0,0,633,617,1,0,0,0,633,625,1,0,0,0,634,67,1,0,0,0,635,636,5,
        49,0,0,636,639,5,75,0,0,637,640,3,10,5,0,638,640,3,64,32,0,639,637,
        1,0,0,0,639,638,1,0,0,0,640,648,1,0,0,0,641,644,5,77,0,0,642,645,
        3,10,5,0,643,645,3,64,32,0,644,642,1,0,0,0,644,643,1,0,0,0,645,647,
        1,0,0,0,646,641,1,0,0,0,647,650,1,0,0,0,648,646,1,0,0,0,648,649,
        1,0,0,0,649,651,1,0,0,0,650,648,1,0,0,0,651,652,5,76,0,0,652,822,
        1,0,0,0,653,654,5,50,0,0,654,657,5,75,0,0,655,658,3,10,5,0,656,658,
        3,64,32,0,657,655,1,0,0,0,657,656,1,0,0,0,658,659,1,0,0,0,659,662,
        5,77,0,0,660,663,3,10,5,0,661,663,3,64,32,0,662,660,1,0,0,0,662,
        661,1,0,0,0,663,664,1,0,0,0,664,667,5,77,0,0,665,668,3,10,5,0,666,
        668,3,64,32,0,667,665,1,0,0,0,667,666,1,0,0,0,668,669,1,0,0,0,669,
        670,5,76,0,0,670,822,1,0,0,0,671,672,5,52,0,0,672,675,5,75,0,0,673,
        676,3,10,5,0,674,676,3,64,32,0,675,673,1,0,0,0,675,674,1,0,0,0,676,
        677,1,0,0,0,677,678,5,76,0,0,678,822,1,0,0,0,679,680,5,51,0,0,680,
        683,5,75,0,0,681,684,3,10,5,0,682,684,3,64,32,0,683,681,1,0,0,0,
        683,682,1,0,0,0,684,685,1,0,0,0,685,686,5,76,0,0,686,822,1,0,0,0,
        687,688,5,53,0,0,688,691,5,75,0,0,689,692,3,10,5,0,690,692,3,64,
        32,0,691,689,1,0,0,0,691,690,1,0,0,0,692,693,1,0,0,0,693,694,5,76,
        0,0,694,822,1,0,0,0,695,696,5,56,0,0,696,699,5,75,0,0,697,700,3,
        10,5,0,698,700,3,64,32,0,699,697,1,0,0,0,699,698,1,0,0,0,700,706,
        1,0,0,0,701,704,5,77,0,0,702,705,3,10,5,0,703,705,3,64,32,0,704,
        702,1,0,0,0,704,703,1,0,0,0,705,707,1,0,0,0,706,701,1,0,0,0,706,
        707,1,0,0,0,707,708,1,0,0,0,708,709,5,76,0,0,709,822,1,0,0,0,710,
        711,5,55,0,0,711,714,5,75,0,0,712,715,3,10,5,0,713,715,3,64,32,0,
        714,712,1,0,0,0,714,713,1,0,0,0,715,721,1,0,0,0,716,719,5,77,0,0,
        717,720,3,10,5,0,718,720,3,64,32,0,719,717,1,0,0,0,719,718,1,0,0,
        0,720,722,1,0,0,0,721,716,1,0,0,0,721,722,1,0,0,0,722,723,1,0,0,
        0,723,724,5,76,0,0,724,822,1,0,0,0,725,726,5,54,0,0,726,729,5,75,
        0,0,727,730,3,10,5,0,728,730,3,64,32,0,729,727,1,0,0,0,729,728,1,
        0,0,0,730,736,1,0,0,0,731,734,5,77,0,0,732,735,3,10,5,0,733,735,
        3,64,32,0,734,732,1,0,0,0,734,733,1,0,0,0,735,737,1,0,0,0,736,731,
        1,0,0,0,736,737,1,0,0,0,737,738,1,0,0,0,738,739,5,76,0,0,739,822,
        1,0,0,0,740,741,5,61,0,0,741,744,5,75,0,0,742,745,3,10,5,0,743,745,
        3,64,32,0,744,742,1,0,0,0,744,743,1,0,0,0,745,746,1,0,0,0,746,749,
        5,77,0,0,747,750,3,10,5,0,748,750,3,64,32,0,749,747,1,0,0,0,749,
        748,1,0,0,0,750,756,1,0,0,0,751,754,5,77,0,0,752,755,3,10,5,0,753,
        755,3,64,32,0,754,752,1,0,0,0,754,753,1,0,0,0,755,757,1,0,0,0,756,
        751,1,0,0,0,756,757,1,0,0,0,757,758,1,0,0,0,758,759,5,76,0,0,759,
        822,1,0,0,0,760,761,5,48,0,0,761,764,5,75,0,0,762,765,3,10,5,0,763,
        765,3,64,32,0,764,762,1,0,0,0,764,763,1,0,0,0,765,766,1,0,0,0,766,
        767,5,76,0,0,767,822,1,0,0,0,768,769,5,62,0,0,769,772,5,75,0,0,770,
        773,3,10,5,0,771,773,3,64,32,0,772,770,1,0,0,0,772,771,1,0,0,0,773,
        774,1,0,0,0,774,775,5,76,0,0,775,822,1,0,0,0,776,777,5,57,0,0,777,
        780,5,75,0,0,778,781,3,10,5,0,779,781,3,64,32,0,780,778,1,0,0,0,
        780,779,1,0,0,0,781,782,1,0,0,0,782,785,5,77,0,0,783,786,3,10,5,
        0,784,786,3,64,32,0,785,783,1,0,0,0,785,784,1,0,0,0,786,787,1,0,
        0,0,787,788,5,76,0,0,788,822,1,0,0,0,789,790,5,64,0,0,790,793,5,
        75,0,0,791,794,3,10,5,0,792,794,3,64,32,0,793,791,1,0,0,0,793,792,
        1,0,0,0,794,795,1,0,0,0,795,796,5,76,0,0,796,822,1,0,0,0,797,798,
        5,65,0,0,798,801,5,75,0,0,799,802,3,10,5,0,800,802,3,64,32,0,801,
        799,1,0,0,0,801,800,1,0,0,0,802,803,1,0,0,0,803,804,5,76,0,0,804,
        822,1,0,0,0,805,806,5,31,0,0,806,809,5,75,0,0,807,810,3,10,5,0,808,
        810,3,64,32,0,809,807,1,0,0,0,809,808,1,0,0,0,810,811,1,0,0,0,811,
        812,5,76,0,0,812,822,1,0,0,0,813,814,5,63,0,0,814,817,5,75,0,0,815,
        818,3,10,5,0,816,818,3,64,32,0,817,815,1,0,0,0,817,816,1,0,0,0,818,
        819,1,0,0,0,819,820,5,76,0,0,820,822,1,0,0,0,821,635,1,0,0,0,821,
        653,1,0,0,0,821,671,1,0,0,0,821,679,1,0,0,0,821,687,1,0,0,0,821,
        695,1,0,0,0,821,710,1,0,0,0,821,725,1,0,0,0,821,740,1,0,0,0,821,
        760,1,0,0,0,821,768,1,0,0,0,821,776,1,0,0,0,821,789,1,0,0,0,821,
        797,1,0,0,0,821,805,1,0,0,0,821,813,1,0,0,0,822,69,1,0,0,0,823,824,
        5,15,0,0,824,825,5,75,0,0,825,969,5,76,0,0,826,827,5,46,0,0,827,
        830,5,75,0,0,828,831,3,28,14,0,829,831,3,64,32,0,830,828,1,0,0,0,
        830,829,1,0,0,0,831,832,1,0,0,0,832,833,5,76,0,0,833,969,1,0,0,0,
        834,835,5,47,0,0,835,838,5,75,0,0,836,839,3,28,14,0,837,839,3,64,
        32,0,838,836,1,0,0,0,838,837,1,0,0,0,839,840,1,0,0,0,840,841,5,76,
        0,0,841,969,1,0,0,0,842,843,5,7,0,0,843,846,5,75,0,0,844,847,3,28,
        14,0,845,847,3,64,32,0,846,844,1,0,0,0,846,845,1,0,0,0,847,848,1,
        0,0,0,848,849,5,76,0,0,849,969,1,0,0,0,850,851,5,8,0,0,851,854,5,
        75,0,0,852,855,3,28,14,0,853,855,3,64,32,0,854,852,1,0,0,0,854,853,
        1,0,0,0,855,856,1,0,0,0,856,859,5,77,0,0,857,860,3,28,14,0,858,860,
        3,58,29,0,859,857,1,0,0,0,859,858,1,0,0,0,860,861,1,0,0,0,861,862,
        5,77,0,0,862,863,3,58,29,0,863,864,5,76,0,0,864,969,1,0,0,0,865,
        866,5,5,0,0,866,867,5,75,0,0,867,969,5,76,0,0,868,869,5,45,0,0,869,
        872,5,75,0,0,870,873,3,28,14,0,871,873,3,64,32,0,872,870,1,0,0,0,
        872,871,1,0,0,0,873,879,1,0,0,0,874,877,5,77,0,0,875,878,3,28,14,
        0,876,878,3,64,32,0,877,875,1,0,0,0,877,876,1,0,0,0,878,880,1,0,
        0,0,879,874,1,0,0,0,880,881,1,0,0,0,881,879,1,0,0,0,881,882,1,0,
        0,0,882,883,1,0,0,0,883,884,5,76,0,0,884,969,1,0,0,0,885,886,5,60,
        0,0,886,889,5,75,0,0,887,890,3,28,14,0,888,890,3,64,32,0,889,887,
        1,0,0,0,889,888,1,0,0,0,890,896,1,0,0,0,891,894,5,77,0,0,892,895,
        3,28,14,0,893,895,3,64,32,0,894,892,1,0,0,0,894,893,1,0,0,0,895,
        897,1,0,0,0,896,891,1,0,0,0,897,898,1,0,0,0,898,896,1,0,0,0,898,
        899,1,0,0,0,899,900,1,0,0,0,900,901,5,76,0,0,901,969,1,0,0,0,902,
        903,5,58,0,0,903,906,5,75,0,0,904,907,3,28,14,0,905,907,3,64,32,
        0,906,904,1,0,0,0,906,905,1,0,0,0,907,908,1,0,0,0,908,911,5,77,0,
        0,909,912,3,28,14,0,910,912,3,64,32,0,911,909,1,0,0,0,911,910,1,
        0,0,0,912,913,1,0,0,0,913,914,5,76,0,0,914,969,1,0,0,0,915,916,5,
        6,0,0,916,919,5,75,0,0,917,920,3,28,14,0,918,920,3,64,32,0,919,917,
        1,0,0,0,919,918,1,0,0,0,920,921,1,0,0,0,921,922,5,76,0,0,922,969,
        1,0,0,0,923,924,5,18,0,0,924,925,5,75,0,0,925,926,3,58,29,0,926,
        929,5,76,0,0,927,928,5,20,0,0,928,930,3,52,26,0,929,927,1,0,0,0,
        929,930,1,0,0,0,930,969,1,0,0,0,931,932,5,9,0,0,932,933,5,75,0,0,
        933,934,3,58,29,0,934,937,5,76,0,0,935,936,5,20,0,0,936,938,3,52,
        26,0,937,935,1,0,0,0,937,938,1,0,0,0,938,969,1,0,0,0,939,940,5,10,
        0,0,940,941,5,75,0,0,941,942,3,58,29,0,942,945,5,76,0,0,943,944,
        5,20,0,0,944,946,3,52,26,0,945,943,1,0,0,0,945,946,1,0,0,0,946,969,
        1,0,0,0,947,948,5,11,0,0,948,949,5,75,0,0,949,950,3,58,29,0,950,
        953,5,76,0,0,951,952,5,20,0,0,952,954,3,52,26,0,953,951,1,0,0,0,
        953,954,1,0,0,0,954,969,1,0,0,0,955,956,5,12,0,0,956,957,5,75,0,
        0,957,958,3,58,29,0,958,961,5,76,0,0,959,960,5,20,0,0,960,962,3,
        52,26,0,961,959,1,0,0,0,961,962,1,0,0,0,962,969,1,0,0,0,963,964,
        5,13,0,0,964,965,5,75,0,0,965,966,3,52,26,0,966,967,5,76,0,0,967,
        969,1,0,0,0,968,823,1,0,0,0,968,826,1,0,0,0,968,834,1,0,0,0,968,
        842,1,0,0,0,968,850,1,0,0,0,968,865,1,0,0,0,968,868,1,0,0,0,968,
        885,1,0,0,0,968,902,1,0,0,0,968,915,1,0,0,0,968,923,1,0,0,0,968,
        931,1,0,0,0,968,939,1,0,0,0,968,947,1,0,0,0,968,955,1,0,0,0,968,
        963,1,0,0,0,969,71,1,0,0,0,136,75,83,88,94,99,102,108,116,121,128,
        139,145,150,157,162,166,173,180,183,188,192,196,202,204,211,219,
        225,230,234,258,263,267,278,280,283,291,297,301,305,314,322,330,
        338,349,353,356,364,371,380,384,395,397,400,410,412,420,426,430,
        434,443,450,459,467,476,485,499,509,522,528,533,541,549,557,565,
        573,581,589,597,605,610,612,614,621,629,633,639,644,648,657,662,
        667,675,683,691,699,704,706,714,719,721,729,734,736,744,749,754,
        756,764,772,780,785,793,801,809,817,821,830,838,846,854,859,872,
        877,881,889,894,898,906,911,919,929,937,945,953,961,968
    ]

class tradeQueryParser ( Parser ):

    grammarFileName = "tradeQuery.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'|'", "'#'", "'table'", "'`'", "'fieldsummary'", 
                     "'mvexpand'", "'time'", "'timerange'", "'latest'", 
                     "'earliest'", "'first'", "'last'", "'macro'", "'file'", 
                     "'null'", "'eval'", "'stats'", "'values'", "'by'", 
                     "'as'", "'WHERE'", "'rename'", "'reverse'", "'field'", 
                     "'fields'", "'search'", "'head'", "'rex'", "'regex'", 
                     "'dedup'", "'defang'", "'round'", "'min'", "'max'", 
                     "'median'", "'mode'", "'avg'", "'sum'", "'random'", 
                     "'sqrt'", "'range'", "'count'", "'dcount'", "'tonumb'", 
                     "'coalesce'", "'isnull'", "'isnotnull'", "'len'", "'concat'", 
                     "'replace'", "'lower'", "'upper'", "'capitalize'", 
                     "'ltrim'", "'rtrim'", "'trim'", "'match'", "'mvindex'", 
                     "'join'", "'mvjoin'", "'substr'", "'tostring'", "'type'", 
                     "'urlencode'", "'urldecode'", "'AND'", "'OR'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'['", "']'", "'('", "')'", "','", "';'", "'='", "'=='", 
                     "'!='", "'>'", "'<'", "'>='", "'<='", "'+'", "'-'", 
                     "'*'", "'/'", "'++'", "'--'", "'~'" ]

    symbolicNames = [ "<INVALID>", "PIPE", "COMMENT", "TABLE", "TICK", "FIELDSUMMARY", 
                      "MVEXPAND", "TIME", "TIMERANGE", "LATEST", "EARLIEST", 
                      "FIRST", "LAST", "MACRO", "FILE", "NULL", "EVAL", 
                      "STATS", "VALUES", "BY", "AS", "WHERE", "RENAME", 
                      "REVERSE", "FIELD", "FIELDS", "SEARCH", "HEAD", "REX", 
                      "REGEX", "DEDUP", "DEFANG", "ROUND", "MIN", "MAX", 
                      "MEDIAN", "MODE", "AVG", "SUM", "RANDOM", "SQRT", 
                      "RANGE", "COUNT", "DCOUNT", "TONUMB", "COALESCE", 
                      "ISNULL", "ISNOTNULL", "LEN", "CONCAT", "REPLACE", 
                      "LOWER", "UPPER", "CAPITALIZE", "LTRIM", "RTRIM", 
                      "TRIM", "MATCH", "MVINDEX", "JOIN", "MVJOIN", "SUBSTR", 
                      "TOSTRING", "TYPE", "URLENCODE", "URLDECODE", "AND", 
                      "OR", "ID", "NUMBER", "DOUBLE_QUOTED_STRING", "BOOLEAN", 
                      "BOOLNUM", "LBRACK", "RBRACK", "LPAREN", "RPAREN", 
                      "COMMA", "SEMICOLON", "EQUALS", "EQUALS_EQUALS", "NOT_EQUALS", 
                      "GT", "LT", "GTEQ", "LTEQ", "PLUS", "MINUS", "MUL", 
                      "DIV", "INC", "DEC", "BITWISE_NOT", "NEWLINE", "WS" ]

    RULE_program = 0
    RULE_tradeQuery = 1
    RULE_validLine = 2
    RULE_directive = 3
    RULE_expression = 4
    RULE_expressionString = 5
    RULE_logicalStringExpr = 6
    RULE_arithmeticStringExpr = 7
    RULE_factorStringExpr = 8
    RULE_expressionNumeric = 9
    RULE_compareNumericExpr = 10
    RULE_arithmeticNumericResultOnlyExpr = 11
    RULE_termNumericResultOnlyExpr = 12
    RULE_factorNumericResultOnlyExpr = 13
    RULE_expressionAny = 14
    RULE_logicalExpr = 15
    RULE_compareExpr = 16
    RULE_arithmeticExpr = 17
    RULE_termExpr = 18
    RULE_factorExpr = 19
    RULE_value = 20
    RULE_valueStringOnly = 21
    RULE_valueNumericResultOnly = 22
    RULE_unaryExpr = 23
    RULE_numericValue = 24
    RULE_booleanValue = 25
    RULE_stringValue = 26
    RULE_arrayValue = 27
    RULE_arrayValueNumeric = 28
    RULE_variableValue = 29
    RULE_comparisonOperator = 30
    RULE_logicalOperator = 31
    RULE_functionCall = 32
    RULE_numericFunctionCall = 33
    RULE_stringFunctionCall = 34
    RULE_specificFunctionCall = 35

    ruleNames =  [ "program", "tradeQuery", "validLine", "directive", "expression", 
                   "expressionString", "logicalStringExpr", "arithmeticStringExpr", 
                   "factorStringExpr", "expressionNumeric", "compareNumericExpr", 
                   "arithmeticNumericResultOnlyExpr", "termNumericResultOnlyExpr", 
                   "factorNumericResultOnlyExpr", "expressionAny", "logicalExpr", 
                   "compareExpr", "arithmeticExpr", "termExpr", "factorExpr", 
                   "value", "valueStringOnly", "valueNumericResultOnly", 
                   "unaryExpr", "numericValue", "booleanValue", "stringValue", 
                   "arrayValue", "arrayValueNumeric", "variableValue", "comparisonOperator", 
                   "logicalOperator", "functionCall", "numericFunctionCall", 
                   "stringFunctionCall", "specificFunctionCall" ]

    EOF = Token.EOF
    PIPE=1
    COMMENT=2
    TABLE=3
    TICK=4
    FIELDSUMMARY=5
    MVEXPAND=6
    TIME=7
    TIMERANGE=8
    LATEST=9
    EARLIEST=10
    FIRST=11
    LAST=12
    MACRO=13
    FILE=14
    NULL=15
    EVAL=16
    STATS=17
    VALUES=18
    BY=19
    AS=20
    WHERE=21
    RENAME=22
    REVERSE=23
    FIELD=24
    FIELDS=25
    SEARCH=26
    HEAD=27
    REX=28
    REGEX=29
    DEDUP=30
    DEFANG=31
    ROUND=32
    MIN=33
    MAX=34
    MEDIAN=35
    MODE=36
    AVG=37
    SUM=38
    RANDOM=39
    SQRT=40
    RANGE=41
    COUNT=42
    DCOUNT=43
    TONUMB=44
    COALESCE=45
    ISNULL=46
    ISNOTNULL=47
    LEN=48
    CONCAT=49
    REPLACE=50
    LOWER=51
    UPPER=52
    CAPITALIZE=53
    LTRIM=54
    RTRIM=55
    TRIM=56
    MATCH=57
    MVINDEX=58
    JOIN=59
    MVJOIN=60
    SUBSTR=61
    TOSTRING=62
    TYPE=63
    URLENCODE=64
    URLDECODE=65
    AND=66
    OR=67
    ID=68
    NUMBER=69
    DOUBLE_QUOTED_STRING=70
    BOOLEAN=71
    BOOLNUM=72
    LBRACK=73
    RBRACK=74
    LPAREN=75
    RPAREN=76
    COMMA=77
    SEMICOLON=78
    EQUALS=79
    EQUALS_EQUALS=80
    NOT_EQUALS=81
    GT=82
    LT=83
    GTEQ=84
    LTEQ=85
    PLUS=86
    MINUS=87
    MUL=88
    DIV=89
    INC=90
    DEC=91
    BITWISE_NOT=92
    NEWLINE=93
    WS=94

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tradeQuery(self):
            return self.getTypedRuleContext(tradeQueryParser.TradeQueryContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = tradeQueryParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.tradeQuery()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TradeQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.PIPE)
            else:
                return self.getToken(tradeQueryParser.PIPE, i)

        def TABLE(self):
            return self.getToken(tradeQueryParser.TABLE, 0)

        def FILE(self):
            return self.getToken(tradeQueryParser.FILE, 0)

        def EQUALS(self):
            return self.getToken(tradeQueryParser.EQUALS, 0)

        def stringValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.StringValueContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.StringValueContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.NEWLINE)
            else:
                return self.getToken(tradeQueryParser.NEWLINE, i)

        def WHERE(self):
            return self.getToken(tradeQueryParser.WHERE, 0)

        def logicalExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.LogicalExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.LogicalExprContext,i)


        def validLine(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ValidLineContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ValidLineContext,i)


        def TIMERANGE(self):
            return self.getToken(tradeQueryParser.TIMERANGE, 0)

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.COMMA)
            else:
                return self.getToken(tradeQueryParser.COMMA, i)

        def variableValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.VariableValueContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.VariableValueContext,i)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def expressionAny(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ExpressionAnyContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ExpressionAnyContext,i)


        def functionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_tradeQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTradeQuery" ):
                listener.enterTradeQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTradeQuery" ):
                listener.exitTradeQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTradeQuery" ):
                return visitor.visitTradeQuery(self)
            else:
                return visitor.visitChildren(self)




    def tradeQuery(self):

        localctx = tradeQueryParser.TradeQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_tradeQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==93:
                self.state = 74
                self.match(tradeQueryParser.NEWLINE)


            self.state = 77
            self.match(tradeQueryParser.PIPE)
            self.state = 78
            self.match(tradeQueryParser.TABLE)
            self.state = 79
            self.match(tradeQueryParser.FILE)
            self.state = 80
            self.match(tradeQueryParser.EQUALS)
            self.state = 81
            self.stringValue()
            self.state = 88
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==70 or _la==77:
                self.state = 83
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==77:
                    self.state = 82
                    self.match(tradeQueryParser.COMMA)


                self.state = 85
                self.stringValue()
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 91
                self.match(tradeQueryParser.WHERE)
                self.state = 92
                self.logicalExpr()
                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -576465152497106976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 478161907) != 0):
                    self.state = 94
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==77:
                        self.state = 93
                        self.match(tradeQueryParser.COMMA)


                    self.state = 96
                    self.logicalExpr()
                    self.state = 101
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 104
            self.match(tradeQueryParser.NEWLINE)
            self.state = 108
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 105
                    self.validLine() 
                self.state = 110
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 111
                self.match(tradeQueryParser.PIPE)
                self.state = 112
                self.match(tradeQueryParser.TIMERANGE)
                self.state = 113
                self.match(tradeQueryParser.LPAREN)
                self.state = 116
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
                if la_ == 1:
                    self.state = 114
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 115
                    self.functionCall()
                    pass


                self.state = 118
                self.match(tradeQueryParser.COMMA)
                self.state = 121
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                if la_ == 1:
                    self.state = 119
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 120
                    self.variableValue()
                    pass


                self.state = 123
                self.match(tradeQueryParser.COMMA)
                self.state = 124
                self.variableValue()
                self.state = 125
                self.match(tradeQueryParser.RPAREN)
                self.state = 126
                self.match(tradeQueryParser.NEWLINE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValidLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.PIPE)
            else:
                return self.getToken(tradeQueryParser.PIPE, i)

        def directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.DirectiveContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.DirectiveContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.NEWLINE)
            else:
                return self.getToken(tradeQueryParser.NEWLINE, i)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_validLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValidLine" ):
                listener.enterValidLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValidLine" ):
                listener.exitValidLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValidLine" ):
                return visitor.visitValidLine(self)
            else:
                return visitor.visitChildren(self)




    def validLine(self):

        localctx = tradeQueryParser.ValidLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_validLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            self.match(tradeQueryParser.PIPE)
            self.state = 131
            self.directive()
            self.state = 132
            self.match(tradeQueryParser.NEWLINE)
            self.state = 139
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 133
                    self.match(tradeQueryParser.PIPE)
                    self.state = 134
                    self.directive()
                    self.state = 135
                    self.match(tradeQueryParser.NEWLINE) 
                self.state = 141
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEARCH(self):
            return self.getToken(tradeQueryParser.SEARCH, 0)

        def logicalExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.LogicalExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.LogicalExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.COMMA)
            else:
                return self.getToken(tradeQueryParser.COMMA, i)

        def REVERSE(self):
            return self.getToken(tradeQueryParser.REVERSE, 0)

        def DEDUP(self):
            return self.getToken(tradeQueryParser.DEDUP, 0)

        def EVAL(self):
            return self.getToken(tradeQueryParser.EVAL, 0)

        def EQUALS(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.EQUALS)
            else:
                return self.getToken(tradeQueryParser.EQUALS, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ExpressionContext,i)


        def stringValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.StringValueContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.StringValueContext,i)


        def variableValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.VariableValueContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.VariableValueContext,i)


        def STATS(self):
            return self.getToken(tradeQueryParser.STATS, 0)

        def functionCall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.FunctionCallContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.FunctionCallContext,i)


        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.AS)
            else:
                return self.getToken(tradeQueryParser.AS, i)

        def valueStringOnly(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ValueStringOnlyContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ValueStringOnlyContext,i)


        def BY(self):
            return self.getToken(tradeQueryParser.BY, 0)

        def COUNT(self):
            return self.getToken(tradeQueryParser.COUNT, 0)

        def RENAME(self):
            return self.getToken(tradeQueryParser.RENAME, 0)

        def expressionString(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionStringContext,0)


        def FIELDS(self):
            return self.getToken(tradeQueryParser.FIELDS, 0)

        def HEAD(self):
            return self.getToken(tradeQueryParser.HEAD, 0)

        def valueNumericResultOnly(self):
            return self.getTypedRuleContext(tradeQueryParser.ValueNumericResultOnlyContext,0)


        def REX(self):
            return self.getToken(tradeQueryParser.REX, 0)

        def FIELD(self):
            return self.getToken(tradeQueryParser.FIELD, 0)

        def REGEX(self):
            return self.getToken(tradeQueryParser.REGEX, 0)

        def numericFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.NumericFunctionCallContext,0)


        def stringFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.StringFunctionCallContext,0)


        def specificFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.SpecificFunctionCallContext,0)


        def JOIN(self):
            return self.getToken(tradeQueryParser.JOIN, 0)

        def LBRACK(self):
            return self.getToken(tradeQueryParser.LBRACK, 0)

        def tradeQuery(self):
            return self.getTypedRuleContext(tradeQueryParser.TradeQueryContext,0)


        def RBRACK(self):
            return self.getToken(tradeQueryParser.RBRACK, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirective" ):
                listener.enterDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirective" ):
                listener.exitDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirective" ):
                return visitor.visitDirective(self)
            else:
                return visitor.visitChildren(self)




    def directive(self):

        localctx = tradeQueryParser.DirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_directive)
        self._la = 0 # Token type
        try:
            self.state = 258
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [26]:
                self.enterOuterAlt(localctx, 1)
                self.state = 142
                self.match(tradeQueryParser.SEARCH)
                self.state = 143
                self.logicalExpr()
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -576465152497106976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 478161907) != 0):
                    self.state = 145
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==77:
                        self.state = 144
                        self.match(tradeQueryParser.COMMA)


                    self.state = 147
                    self.logicalExpr()
                    self.state = 152
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [23, 30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 153
                _la = self._input.LA(1)
                if not(_la==23 or _la==30):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 3)
                self.state = 154
                self.match(tradeQueryParser.EVAL)
                self.state = 157
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [70]:
                    self.state = 155
                    self.stringValue()
                    pass
                elif token in [68]:
                    self.state = 156
                    self.variableValue()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 159
                self.match(tradeQueryParser.EQUALS)
                self.state = 160
                self.expression()
                self.state = 173
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 517) != 0):
                    self.state = 162
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==77:
                        self.state = 161
                        self.match(tradeQueryParser.COMMA)


                    self.state = 166
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [70]:
                        self.state = 164
                        self.stringValue()
                        pass
                    elif token in [68]:
                        self.state = 165
                        self.variableValue()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 168
                    self.match(tradeQueryParser.EQUALS)
                    self.state = 169
                    self.expression()
                    self.state = 175
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 4)
                self.state = 176
                self.match(tradeQueryParser.STATS)
                self.state = 177
                self.functionCall()
                self.state = 180
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==20:
                    self.state = 178
                    self.match(tradeQueryParser.AS)
                    self.state = 179
                    self.valueStringOnly()


                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & -576465152497106976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 8195) != 0):
                    self.state = 183
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==77:
                        self.state = 182
                        self.match(tradeQueryParser.COMMA)


                    self.state = 185
                    self.functionCall()
                    self.state = 188
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==20:
                        self.state = 186
                        self.match(tradeQueryParser.AS)
                        self.state = 187
                        self.valueStringOnly()


                    self.state = 194
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==19 or _la==42:
                    self.state = 196
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==42:
                        self.state = 195
                        self.match(tradeQueryParser.COUNT)


                    self.state = 198
                    self.match(tradeQueryParser.BY)
                    self.state = 200 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 199
                        self.variableValue()
                        self.state = 202 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==68):
                            break



                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 5)
                self.state = 206
                self.match(tradeQueryParser.RENAME)
                self.state = 207
                self.variableValue()
                self.state = 208
                self.match(tradeQueryParser.AS)
                self.state = 209
                self.expressionString()
                self.state = 219
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==68 or _la==77:
                    self.state = 211
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==77:
                        self.state = 210
                        self.match(tradeQueryParser.COMMA)


                    self.state = 213
                    self.variableValue()
                    self.state = 214
                    self.match(tradeQueryParser.AS)
                    self.state = 215
                    self.valueStringOnly()
                    self.state = 221
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 6)
                self.state = 222
                self.match(tradeQueryParser.FIELDS)
                self.state = 223
                self.variableValue()
                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==68 or _la==77:
                    self.state = 225
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==77:
                        self.state = 224
                        self.match(tradeQueryParser.COMMA)


                    self.state = 227
                    self.variableValue()
                    self.state = 230
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==20:
                        self.state = 228
                        self.match(tradeQueryParser.AS)
                        self.state = 229
                        self.valueStringOnly()


                    self.state = 236
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 7)
                self.state = 237
                self.match(tradeQueryParser.HEAD)
                self.state = 238
                self.valueNumericResultOnly()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 8)
                self.state = 239
                self.match(tradeQueryParser.REX)
                self.state = 240
                self.match(tradeQueryParser.FIELD)
                self.state = 241
                self.match(tradeQueryParser.EQUALS)
                self.state = 242
                self.variableValue()
                self.state = 243
                self.stringValue()
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 9)
                self.state = 245
                self.match(tradeQueryParser.REGEX)
                self.state = 246
                self.variableValue()
                self.state = 247
                self.match(tradeQueryParser.EQUALS)
                self.state = 248
                self.stringValue()
                pass
            elif token in [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44]:
                self.enterOuterAlt(localctx, 10)
                self.state = 250
                self.numericFunctionCall()
                pass
            elif token in [31, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 61, 62, 63, 64, 65]:
                self.enterOuterAlt(localctx, 11)
                self.state = 251
                self.stringFunctionCall()
                pass
            elif token in [5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 45, 46, 47, 58, 60]:
                self.enterOuterAlt(localctx, 12)
                self.state = 252
                self.specificFunctionCall()
                pass
            elif token in [59]:
                self.enterOuterAlt(localctx, 13)
                self.state = 253
                self.match(tradeQueryParser.JOIN)
                self.state = 254
                self.match(tradeQueryParser.LBRACK)
                self.state = 255
                self.tradeQuery()
                self.state = 256
                self.match(tradeQueryParser.RBRACK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionNumeric(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionNumericContext,0)


        def expressionString(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionStringContext,0)


        def expressionAny(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionAnyContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = tradeQueryParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_expression)
        try:
            self.state = 263
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 260
                self.expressionNumeric()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 261
                self.expressionString()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 262
                self.expressionAny()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.StringFunctionCallContext,0)


        def logicalStringExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.LogicalStringExprContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_expressionString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionString" ):
                listener.enterExpressionString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionString" ):
                listener.exitExpressionString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionString" ):
                return visitor.visitExpressionString(self)
            else:
                return visitor.visitChildren(self)




    def expressionString(self):

        localctx = tradeQueryParser.ExpressionStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_expressionString)
        try:
            self.state = 267
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 265
                self.stringFunctionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 266
                self.logicalStringExpr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalStringExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def logicalStringExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.LogicalStringExprContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def arithmeticStringExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ArithmeticStringExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ArithmeticStringExprContext,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.AND)
            else:
                return self.getToken(tradeQueryParser.AND, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.OR)
            else:
                return self.getToken(tradeQueryParser.OR, i)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_logicalStringExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalStringExpr" ):
                listener.enterLogicalStringExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalStringExpr" ):
                listener.exitLogicalStringExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalStringExpr" ):
                return visitor.visitLogicalStringExpr(self)
            else:
                return visitor.visitChildren(self)




    def logicalStringExpr(self):

        localctx = tradeQueryParser.LogicalStringExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_logicalStringExpr)
        self._la = 0 # Token type
        try:
            self.state = 283
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 269
                self.match(tradeQueryParser.LPAREN)
                self.state = 270
                self.logicalStringExpr()
                self.state = 271
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 273
                self.arithmeticStringExpr(0)
                self.state = 280
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==66 or _la==67:
                    self.state = 278
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [66]:
                        self.state = 274
                        self.match(tradeQueryParser.AND)
                        self.state = 275
                        self.arithmeticStringExpr(0)
                        pass
                    elif token in [67]:
                        self.state = 276
                        self.match(tradeQueryParser.OR)
                        self.state = 277
                        self.arithmeticStringExpr(0)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 282
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticStringExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def arithmeticStringExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ArithmeticStringExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ArithmeticStringExprContext,i)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def factorStringExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.FactorStringExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.FactorStringExprContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.PLUS)
            else:
                return self.getToken(tradeQueryParser.PLUS, i)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_arithmeticStringExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticStringExpr" ):
                listener.enterArithmeticStringExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticStringExpr" ):
                listener.exitArithmeticStringExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticStringExpr" ):
                return visitor.visitArithmeticStringExpr(self)
            else:
                return visitor.visitChildren(self)



    def arithmeticStringExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = tradeQueryParser.ArithmeticStringExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 14
        self.enterRecursionRule(localctx, 14, self.RULE_arithmeticStringExpr, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 291
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 286
                self.match(tradeQueryParser.LPAREN)
                self.state = 287
                self.arithmeticStringExpr(0)
                self.state = 288
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.state = 290
                self.factorStringExpr()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 305
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = tradeQueryParser.ArithmeticStringExprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_arithmeticStringExpr)
                    self.state = 293
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 299 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 294
                            self.match(tradeQueryParser.PLUS)
                            self.state = 297
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                            if la_ == 1:
                                self.state = 295
                                self.factorStringExpr()
                                pass

                            elif la_ == 2:
                                self.state = 296
                                self.arithmeticStringExpr(0)
                                pass



                        else:
                            raise NoViableAltException(self)
                        self.state = 301 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,37,self._ctx)
             
                self.state = 307
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorStringExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arrayValue(self):
            return self.getTypedRuleContext(tradeQueryParser.ArrayValueContext,0)


        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def expressionString(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionStringContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def value(self):
            return self.getTypedRuleContext(tradeQueryParser.ValueContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_factorStringExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorStringExpr" ):
                listener.enterFactorStringExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorStringExpr" ):
                listener.exitFactorStringExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorStringExpr" ):
                return visitor.visitFactorStringExpr(self)
            else:
                return visitor.visitChildren(self)




    def factorStringExpr(self):

        localctx = tradeQueryParser.FactorStringExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_factorStringExpr)
        try:
            self.state = 314
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [73]:
                self.enterOuterAlt(localctx, 1)
                self.state = 308
                self.arrayValue()
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 2)
                self.state = 309
                self.match(tradeQueryParser.LPAREN)
                self.state = 310
                self.expressionString()
                self.state = 311
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 72, 87, 90, 91, 92]:
                self.enterOuterAlt(localctx, 3)
                self.state = 313
                self.value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionNumericContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def expressionNumeric(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionNumericContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def numericFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.NumericFunctionCallContext,0)


        def compareNumericExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.CompareNumericExprContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_expressionNumeric

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionNumeric" ):
                listener.enterExpressionNumeric(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionNumeric" ):
                listener.exitExpressionNumeric(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionNumeric" ):
                return visitor.visitExpressionNumeric(self)
            else:
                return visitor.visitChildren(self)




    def expressionNumeric(self):

        localctx = tradeQueryParser.ExpressionNumericContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_expressionNumeric)
        try:
            self.state = 322
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 316
                self.match(tradeQueryParser.LPAREN)
                self.state = 317
                self.expressionNumeric()
                self.state = 318
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 320
                self.numericFunctionCall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 321
                self.compareNumericExpr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompareNumericExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def compareNumericExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.CompareNumericExprContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def arithmeticNumericResultOnlyExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.ArithmeticNumericResultOnlyExprContext,0)


        def comparisonOperator(self):
            return self.getTypedRuleContext(tradeQueryParser.ComparisonOperatorContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_compareNumericExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompareNumericExpr" ):
                listener.enterCompareNumericExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompareNumericExpr" ):
                listener.exitCompareNumericExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompareNumericExpr" ):
                return visitor.visitCompareNumericExpr(self)
            else:
                return visitor.visitChildren(self)



    def compareNumericExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = tradeQueryParser.CompareNumericExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 20
        self.enterRecursionRule(localctx, 20, self.RULE_compareNumericExpr, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.state = 325
                self.match(tradeQueryParser.LPAREN)
                self.state = 326
                self.compareNumericExpr(0)
                self.state = 327
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.state = 329
                self.arithmeticNumericResultOnlyExpr()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 338
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = tradeQueryParser.CompareNumericExprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_compareNumericExpr)
                    self.state = 332
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 333
                    self.comparisonOperator()
                    self.state = 334
                    self.arithmeticNumericResultOnlyExpr() 
                self.state = 340
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ArithmeticNumericResultOnlyExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def arithmeticNumericResultOnlyExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.ArithmeticNumericResultOnlyExprContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def arithmeticExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ArithmeticExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ArithmeticExprContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.PLUS)
            else:
                return self.getToken(tradeQueryParser.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.MINUS)
            else:
                return self.getToken(tradeQueryParser.MINUS, i)

        def termNumericResultOnlyExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.TermNumericResultOnlyExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.TermNumericResultOnlyExprContext,i)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_arithmeticNumericResultOnlyExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticNumericResultOnlyExpr" ):
                listener.enterArithmeticNumericResultOnlyExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticNumericResultOnlyExpr" ):
                listener.exitArithmeticNumericResultOnlyExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticNumericResultOnlyExpr" ):
                return visitor.visitArithmeticNumericResultOnlyExpr(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticNumericResultOnlyExpr(self):

        localctx = tradeQueryParser.ArithmeticNumericResultOnlyExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_arithmeticNumericResultOnlyExpr)
        self._la = 0 # Token type
        try:
            self.state = 356
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 341
                self.match(tradeQueryParser.LPAREN)
                self.state = 342
                self.arithmeticNumericResultOnlyExpr()
                self.state = 343
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 345
                self.arithmeticExpr(0)
                self.state = 351 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 346
                        _la = self._input.LA(1)
                        if not(_la==86 or _la==87):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 349
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
                        if la_ == 1:
                            self.state = 347
                            self.termNumericResultOnlyExpr(0)
                            pass

                        elif la_ == 2:
                            self.state = 348
                            self.arithmeticExpr(0)
                            pass



                    else:
                        raise NoViableAltException(self)
                    self.state = 353 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,44,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 355
                self.termNumericResultOnlyExpr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermNumericResultOnlyExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def termNumericResultOnlyExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.TermNumericResultOnlyExprContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def factorNumericResultOnlyExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.FactorNumericResultOnlyExprContext,0)


        def MUL(self):
            return self.getToken(tradeQueryParser.MUL, 0)

        def DIV(self):
            return self.getToken(tradeQueryParser.DIV, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_termNumericResultOnlyExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermNumericResultOnlyExpr" ):
                listener.enterTermNumericResultOnlyExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermNumericResultOnlyExpr" ):
                listener.exitTermNumericResultOnlyExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTermNumericResultOnlyExpr" ):
                return visitor.visitTermNumericResultOnlyExpr(self)
            else:
                return visitor.visitChildren(self)



    def termNumericResultOnlyExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = tradeQueryParser.TermNumericResultOnlyExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_termNumericResultOnlyExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 364
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 359
                self.match(tradeQueryParser.LPAREN)
                self.state = 360
                self.termNumericResultOnlyExpr(0)
                self.state = 361
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.state = 363
                self.factorNumericResultOnlyExpr()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 371
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,47,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = tradeQueryParser.TermNumericResultOnlyExprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_termNumericResultOnlyExpr)
                    self.state = 366
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 367
                    _la = self._input.LA(1)
                    if not(_la==88 or _la==89):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 368
                    self.factorNumericResultOnlyExpr() 
                self.state = 373
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorNumericResultOnlyExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arrayValueNumeric(self):
            return self.getTypedRuleContext(tradeQueryParser.ArrayValueNumericContext,0)


        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def expressionNumeric(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionNumericContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def valueNumericResultOnly(self):
            return self.getTypedRuleContext(tradeQueryParser.ValueNumericResultOnlyContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_factorNumericResultOnlyExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorNumericResultOnlyExpr" ):
                listener.enterFactorNumericResultOnlyExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorNumericResultOnlyExpr" ):
                listener.exitFactorNumericResultOnlyExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorNumericResultOnlyExpr" ):
                return visitor.visitFactorNumericResultOnlyExpr(self)
            else:
                return visitor.visitChildren(self)




    def factorNumericResultOnlyExpr(self):

        localctx = tradeQueryParser.FactorNumericResultOnlyExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_factorNumericResultOnlyExpr)
        try:
            self.state = 380
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [73]:
                self.enterOuterAlt(localctx, 1)
                self.state = 374
                self.arrayValueNumeric()
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 2)
                self.state = 375
                self.match(tradeQueryParser.LPAREN)
                self.state = 376
                self.expressionNumeric()
                self.state = 377
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 68, 69, 72, 87, 90, 91, 92]:
                self.enterOuterAlt(localctx, 3)
                self.state = 379
                self.valueNumericResultOnly()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionAnyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.FunctionCallContext,0)


        def logicalExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.LogicalExprContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_expressionAny

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionAny" ):
                listener.enterExpressionAny(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionAny" ):
                listener.exitExpressionAny(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionAny" ):
                return visitor.visitExpressionAny(self)
            else:
                return visitor.visitChildren(self)




    def expressionAny(self):

        localctx = tradeQueryParser.ExpressionAnyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_expressionAny)
        try:
            self.state = 384
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 382
                self.functionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 383
                self.logicalExpr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def logicalExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.LogicalExprContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def compareExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.CompareExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.CompareExprContext,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.AND)
            else:
                return self.getToken(tradeQueryParser.AND, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.OR)
            else:
                return self.getToken(tradeQueryParser.OR, i)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_logicalExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpr" ):
                listener.enterLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpr" ):
                listener.exitLogicalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpr" ):
                return visitor.visitLogicalExpr(self)
            else:
                return visitor.visitChildren(self)




    def logicalExpr(self):

        localctx = tradeQueryParser.LogicalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_logicalExpr)
        self._la = 0 # Token type
        try:
            self.state = 400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 386
                self.match(tradeQueryParser.LPAREN)
                self.state = 387
                self.logicalExpr()
                self.state = 388
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 390
                self.compareExpr()
                self.state = 397
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==66 or _la==67:
                    self.state = 395
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [66]:
                        self.state = 391
                        self.match(tradeQueryParser.AND)
                        self.state = 392
                        self.compareExpr()
                        pass
                    elif token in [67]:
                        self.state = 393
                        self.match(tradeQueryParser.OR)
                        self.state = 394
                        self.compareExpr()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 399
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompareExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def compareExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.CompareExprContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def arithmeticExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ArithmeticExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ArithmeticExprContext,i)


        def comparisonOperator(self):
            return self.getTypedRuleContext(tradeQueryParser.ComparisonOperatorContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_compareExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompareExpr" ):
                listener.enterCompareExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompareExpr" ):
                listener.exitCompareExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompareExpr" ):
                return visitor.visitCompareExpr(self)
            else:
                return visitor.visitChildren(self)




    def compareExpr(self):

        localctx = tradeQueryParser.CompareExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_compareExpr)
        self._la = 0 # Token type
        try:
            self.state = 412
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 402
                self.match(tradeQueryParser.LPAREN)
                self.state = 403
                self.compareExpr()
                self.state = 404
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 406
                self.arithmeticExpr(0)
                self.state = 410
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 80)) & ~0x3f) == 0 and ((1 << (_la - 80)) & 63) != 0):
                    self.state = 407
                    self.comparisonOperator()
                    self.state = 408
                    self.arithmeticExpr(0)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def arithmeticExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ArithmeticExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ArithmeticExprContext,i)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def termExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.TermExprContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.TermExprContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.PLUS)
            else:
                return self.getToken(tradeQueryParser.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.MINUS)
            else:
                return self.getToken(tradeQueryParser.MINUS, i)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_arithmeticExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticExpr" ):
                listener.enterArithmeticExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticExpr" ):
                listener.exitArithmeticExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticExpr" ):
                return visitor.visitArithmeticExpr(self)
            else:
                return visitor.visitChildren(self)



    def arithmeticExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = tradeQueryParser.ArithmeticExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 34
        self.enterRecursionRule(localctx, 34, self.RULE_arithmeticExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 420
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                self.state = 415
                self.match(tradeQueryParser.LPAREN)
                self.state = 416
                self.arithmeticExpr(0)
                self.state = 417
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.state = 419
                self.termExpr(0)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 434
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,58,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = tradeQueryParser.ArithmeticExprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_arithmeticExpr)
                    self.state = 422
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 428 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 423
                            _la = self._input.LA(1)
                            if not(_la==86 or _la==87):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 426
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
                            if la_ == 1:
                                self.state = 424
                                self.termExpr(0)
                                pass

                            elif la_ == 2:
                                self.state = 425
                                self.arithmeticExpr(0)
                                pass



                        else:
                            raise NoViableAltException(self)
                        self.state = 430 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,57,self._ctx)
             
                self.state = 436
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,58,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def termExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.TermExprContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def factorExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.FactorExprContext,0)


        def MUL(self):
            return self.getToken(tradeQueryParser.MUL, 0)

        def DIV(self):
            return self.getToken(tradeQueryParser.DIV, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_termExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermExpr" ):
                listener.enterTermExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermExpr" ):
                listener.exitTermExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTermExpr" ):
                return visitor.visitTermExpr(self)
            else:
                return visitor.visitChildren(self)



    def termExpr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = tradeQueryParser.TermExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 36
        self.enterRecursionRule(localctx, 36, self.RULE_termExpr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 443
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 438
                self.match(tradeQueryParser.LPAREN)
                self.state = 439
                self.termExpr(0)
                self.state = 440
                self.match(tradeQueryParser.RPAREN)
                pass

            elif la_ == 2:
                self.state = 442
                self.factorExpr()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 450
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,60,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = tradeQueryParser.TermExprContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_termExpr)
                    self.state = 445
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 446
                    _la = self._input.LA(1)
                    if not(_la==88 or _la==89):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 447
                    self.factorExpr() 
                self.state = 452
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,60,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arrayValue(self):
            return self.getTypedRuleContext(tradeQueryParser.ArrayValueContext,0)


        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def expressionAny(self):
            return self.getTypedRuleContext(tradeQueryParser.ExpressionAnyContext,0)


        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def value(self):
            return self.getTypedRuleContext(tradeQueryParser.ValueContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_factorExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorExpr" ):
                listener.enterFactorExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorExpr" ):
                listener.exitFactorExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorExpr" ):
                return visitor.visitFactorExpr(self)
            else:
                return visitor.visitChildren(self)




    def factorExpr(self):

        localctx = tradeQueryParser.FactorExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_factorExpr)
        try:
            self.state = 459
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [73]:
                self.enterOuterAlt(localctx, 1)
                self.state = 453
                self.arrayValue()
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 2)
                self.state = 454
                self.match(tradeQueryParser.LPAREN)
                self.state = 455
                self.expressionAny()
                self.state = 456
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 72, 87, 90, 91, 92]:
                self.enterOuterAlt(localctx, 3)
                self.state = 458
                self.value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.UnaryExprContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.FunctionCallContext,0)


        def numericValue(self):
            return self.getTypedRuleContext(tradeQueryParser.NumericValueContext,0)


        def booleanValue(self):
            return self.getTypedRuleContext(tradeQueryParser.BooleanValueContext,0)


        def stringValue(self):
            return self.getTypedRuleContext(tradeQueryParser.StringValueContext,0)


        def variableValue(self):
            return self.getTypedRuleContext(tradeQueryParser.VariableValueContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = tradeQueryParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_value)
        try:
            self.state = 467
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 461
                self.unaryExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 462
                self.functionCall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 463
                self.numericValue()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 464
                self.booleanValue()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 465
                self.stringValue()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 466
                self.variableValue()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueStringOnlyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringValue(self):
            return self.getTypedRuleContext(tradeQueryParser.StringValueContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_valueStringOnly

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueStringOnly" ):
                listener.enterValueStringOnly(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueStringOnly" ):
                listener.exitValueStringOnly(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueStringOnly" ):
                return visitor.visitValueStringOnly(self)
            else:
                return visitor.visitChildren(self)




    def valueStringOnly(self):

        localctx = tradeQueryParser.ValueStringOnlyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_valueStringOnly)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 469
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueNumericResultOnlyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryExpr(self):
            return self.getTypedRuleContext(tradeQueryParser.UnaryExprContext,0)


        def numericFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.NumericFunctionCallContext,0)


        def numericValue(self):
            return self.getTypedRuleContext(tradeQueryParser.NumericValueContext,0)


        def BOOLNUM(self):
            return self.getToken(tradeQueryParser.BOOLNUM, 0)

        def variableValue(self):
            return self.getTypedRuleContext(tradeQueryParser.VariableValueContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_valueNumericResultOnly

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueNumericResultOnly" ):
                listener.enterValueNumericResultOnly(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueNumericResultOnly" ):
                listener.exitValueNumericResultOnly(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueNumericResultOnly" ):
                return visitor.visitValueNumericResultOnly(self)
            else:
                return visitor.visitChildren(self)




    def valueNumericResultOnly(self):

        localctx = tradeQueryParser.ValueNumericResultOnlyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_valueNumericResultOnly)
        try:
            self.state = 476
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 471
                self.unaryExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 472
                self.numericFunctionCall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 473
                self.numericValue()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 474
                self.match(tradeQueryParser.BOOLNUM)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 475
                self.variableValue()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numericValue(self):
            return self.getTypedRuleContext(tradeQueryParser.NumericValueContext,0)


        def INC(self):
            return self.getToken(tradeQueryParser.INC, 0)

        def DEC(self):
            return self.getToken(tradeQueryParser.DEC, 0)

        def BITWISE_NOT(self):
            return self.getToken(tradeQueryParser.BITWISE_NOT, 0)

        def MINUS(self):
            return self.getToken(tradeQueryParser.MINUS, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_unaryExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryExpr" ):
                listener.enterUnaryExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryExpr" ):
                listener.exitUnaryExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryExpr" ):
                return visitor.visitUnaryExpr(self)
            else:
                return visitor.visitChildren(self)




    def unaryExpr(self):

        localctx = tradeQueryParser.UnaryExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_unaryExpr)
        self._la = 0 # Token type
        try:
            self.state = 485
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [69]:
                self.enterOuterAlt(localctx, 1)
                self.state = 478
                self.numericValue()
                self.state = 479
                _la = self._input.LA(1)
                if not(((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & 7) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [90, 91, 92]:
                self.enterOuterAlt(localctx, 2)
                self.state = 481
                _la = self._input.LA(1)
                if not(((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & 7) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 482
                self.numericValue()
                pass
            elif token in [87]:
                self.enterOuterAlt(localctx, 3)
                self.state = 483
                self.match(tradeQueryParser.MINUS)
                self.state = 484
                self.numericValue()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(tradeQueryParser.NUMBER, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_numericValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericValue" ):
                listener.enterNumericValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericValue" ):
                listener.exitNumericValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericValue" ):
                return visitor.visitNumericValue(self)
            else:
                return visitor.visitChildren(self)




    def numericValue(self):

        localctx = tradeQueryParser.NumericValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_numericValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            self.match(tradeQueryParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(tradeQueryParser.BOOLEAN, 0)

        def BOOLNUM(self):
            return self.getToken(tradeQueryParser.BOOLNUM, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanValue" ):
                return visitor.visitBooleanValue(self)
            else:
                return visitor.visitChildren(self)




    def booleanValue(self):

        localctx = tradeQueryParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 489
            _la = self._input.LA(1)
            if not(_la==71 or _la==72):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOUBLE_QUOTED_STRING(self):
            return self.getToken(tradeQueryParser.DOUBLE_QUOTED_STRING, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_stringValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringValue" ):
                listener.enterStringValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringValue" ):
                listener.exitStringValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringValue" ):
                return visitor.visitStringValue(self)
            else:
                return visitor.visitChildren(self)




    def stringValue(self):

        localctx = tradeQueryParser.StringValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_stringValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 491
            self.match(tradeQueryParser.DOUBLE_QUOTED_STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(tradeQueryParser.LBRACK, 0)

        def expressionAny(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ExpressionAnyContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ExpressionAnyContext,i)


        def RBRACK(self):
            return self.getToken(tradeQueryParser.RBRACK, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.COMMA)
            else:
                return self.getToken(tradeQueryParser.COMMA, i)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_arrayValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayValue" ):
                listener.enterArrayValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayValue" ):
                listener.exitArrayValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayValue" ):
                return visitor.visitArrayValue(self)
            else:
                return visitor.visitChildren(self)




    def arrayValue(self):

        localctx = tradeQueryParser.ArrayValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_arrayValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.match(tradeQueryParser.LBRACK)
            self.state = 494
            self.expressionAny()
            self.state = 497 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 495
                self.match(tradeQueryParser.COMMA)
                self.state = 496
                self.expressionAny()
                self.state = 499 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==77):
                    break

            self.state = 501
            self.match(tradeQueryParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayValueNumericContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(tradeQueryParser.LBRACK, 0)

        def expressionNumeric(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ExpressionNumericContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ExpressionNumericContext,i)


        def RBRACK(self):
            return self.getToken(tradeQueryParser.RBRACK, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.COMMA)
            else:
                return self.getToken(tradeQueryParser.COMMA, i)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_arrayValueNumeric

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayValueNumeric" ):
                listener.enterArrayValueNumeric(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayValueNumeric" ):
                listener.exitArrayValueNumeric(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayValueNumeric" ):
                return visitor.visitArrayValueNumeric(self)
            else:
                return visitor.visitChildren(self)




    def arrayValueNumeric(self):

        localctx = tradeQueryParser.ArrayValueNumericContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_arrayValueNumeric)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 503
            self.match(tradeQueryParser.LBRACK)
            self.state = 504
            self.expressionNumeric()
            self.state = 507 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 505
                self.match(tradeQueryParser.COMMA)
                self.state = 506
                self.expressionNumeric()
                self.state = 509 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==77):
                    break

            self.state = 511
            self.match(tradeQueryParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(tradeQueryParser.ID, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_variableValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableValue" ):
                listener.enterVariableValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableValue" ):
                listener.exitVariableValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableValue" ):
                return visitor.visitVariableValue(self)
            else:
                return visitor.visitChildren(self)




    def variableValue(self):

        localctx = tradeQueryParser.VariableValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_variableValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 513
            self.match(tradeQueryParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS_EQUALS(self):
            return self.getToken(tradeQueryParser.EQUALS_EQUALS, 0)

        def NOT_EQUALS(self):
            return self.getToken(tradeQueryParser.NOT_EQUALS, 0)

        def GT(self):
            return self.getToken(tradeQueryParser.GT, 0)

        def LT(self):
            return self.getToken(tradeQueryParser.LT, 0)

        def GTEQ(self):
            return self.getToken(tradeQueryParser.GTEQ, 0)

        def LTEQ(self):
            return self.getToken(tradeQueryParser.LTEQ, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = tradeQueryParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            _la = self._input.LA(1)
            if not(((((_la - 80)) & ~0x3f) == 0 and ((1 << (_la - 80)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(tradeQueryParser.AND, 0)

        def OR(self):
            return self.getToken(tradeQueryParser.OR, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_logicalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOperator" ):
                listener.enterLogicalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOperator" ):
                listener.exitLogicalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalOperator" ):
                return visitor.visitLogicalOperator(self)
            else:
                return visitor.visitChildren(self)




    def logicalOperator(self):

        localctx = tradeQueryParser.LogicalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_logicalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 517
            _la = self._input.LA(1)
            if not(_la==66 or _la==67):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numericFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.NumericFunctionCallContext,0)


        def stringFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.StringFunctionCallContext,0)


        def specificFunctionCall(self):
            return self.getTypedRuleContext(tradeQueryParser.SpecificFunctionCallContext,0)


        def getRuleIndex(self):
            return tradeQueryParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = tradeQueryParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_functionCall)
        try:
            self.state = 522
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 519
                self.numericFunctionCall()
                pass
            elif token in [31, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 61, 62, 63, 64, 65]:
                self.enterOuterAlt(localctx, 2)
                self.state = 520
                self.stringFunctionCall()
                pass
            elif token in [5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 45, 46, 47, 58, 60]:
                self.enterOuterAlt(localctx, 3)
                self.state = 521
                self.specificFunctionCall()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND(self):
            return self.getToken(tradeQueryParser.ROUND, 0)

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def COMMA(self):
            return self.getToken(tradeQueryParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def expressionNumeric(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ExpressionNumericContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ExpressionNumericContext,i)


        def numericFunctionCall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.NumericFunctionCallContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.NumericFunctionCallContext,i)


        def MIN(self):
            return self.getToken(tradeQueryParser.MIN, 0)

        def MAX(self):
            return self.getToken(tradeQueryParser.MAX, 0)

        def AVG(self):
            return self.getToken(tradeQueryParser.AVG, 0)

        def SUM(self):
            return self.getToken(tradeQueryParser.SUM, 0)

        def RANGE(self):
            return self.getToken(tradeQueryParser.RANGE, 0)

        def MEDIAN(self):
            return self.getToken(tradeQueryParser.MEDIAN, 0)

        def MODE(self):
            return self.getToken(tradeQueryParser.MODE, 0)

        def SQRT(self):
            return self.getToken(tradeQueryParser.SQRT, 0)

        def RANDOM(self):
            return self.getToken(tradeQueryParser.RANDOM, 0)

        def TONUMB(self):
            return self.getToken(tradeQueryParser.TONUMB, 0)

        def DCOUNT(self):
            return self.getToken(tradeQueryParser.DCOUNT, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_numericFunctionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericFunctionCall" ):
                listener.enterNumericFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericFunctionCall" ):
                listener.exitNumericFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericFunctionCall" ):
                return visitor.visitNumericFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def numericFunctionCall(self):

        localctx = tradeQueryParser.NumericFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_numericFunctionCall)
        self._la = 0 # Token type
        try:
            self.state = 633
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32]:
                self.enterOuterAlt(localctx, 1)
                self.state = 524
                self.match(tradeQueryParser.ROUND)
                self.state = 525
                self.match(tradeQueryParser.LPAREN)
                self.state = 528
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                if la_ == 1:
                    self.state = 526
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 527
                    self.numericFunctionCall()
                    pass


                self.state = 530
                self.match(tradeQueryParser.COMMA)
                self.state = 533
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
                if la_ == 1:
                    self.state = 531
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 532
                    self.numericFunctionCall()
                    pass


                self.state = 535
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 2)
                self.state = 537
                self.match(tradeQueryParser.MIN)
                self.state = 538
                self.match(tradeQueryParser.LPAREN)
                self.state = 541
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 539
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 540
                    self.numericFunctionCall()
                    pass


                self.state = 543
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [34]:
                self.enterOuterAlt(localctx, 3)
                self.state = 545
                self.match(tradeQueryParser.MAX)
                self.state = 546
                self.match(tradeQueryParser.LPAREN)
                self.state = 549
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
                if la_ == 1:
                    self.state = 547
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 548
                    self.numericFunctionCall()
                    pass


                self.state = 551
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [37]:
                self.enterOuterAlt(localctx, 4)
                self.state = 553
                self.match(tradeQueryParser.AVG)
                self.state = 554
                self.match(tradeQueryParser.LPAREN)
                self.state = 557
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
                if la_ == 1:
                    self.state = 555
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 556
                    self.numericFunctionCall()
                    pass


                self.state = 559
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 5)
                self.state = 561
                self.match(tradeQueryParser.SUM)
                self.state = 562
                self.match(tradeQueryParser.LPAREN)
                self.state = 565
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                if la_ == 1:
                    self.state = 563
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 564
                    self.numericFunctionCall()
                    pass


                self.state = 567
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 6)
                self.state = 569
                self.match(tradeQueryParser.RANGE)
                self.state = 570
                self.match(tradeQueryParser.LPAREN)
                self.state = 573
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                if la_ == 1:
                    self.state = 571
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 572
                    self.numericFunctionCall()
                    pass


                self.state = 575
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 7)
                self.state = 577
                self.match(tradeQueryParser.MEDIAN)
                self.state = 578
                self.match(tradeQueryParser.LPAREN)
                self.state = 581
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                if la_ == 1:
                    self.state = 579
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 580
                    self.numericFunctionCall()
                    pass


                self.state = 583
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [36]:
                self.enterOuterAlt(localctx, 8)
                self.state = 585
                self.match(tradeQueryParser.MODE)
                self.state = 586
                self.match(tradeQueryParser.LPAREN)
                self.state = 589
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                if la_ == 1:
                    self.state = 587
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 588
                    self.numericFunctionCall()
                    pass


                self.state = 591
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 9)
                self.state = 593
                self.match(tradeQueryParser.SQRT)
                self.state = 594
                self.match(tradeQueryParser.LPAREN)
                self.state = 597
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 595
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 596
                    self.numericFunctionCall()
                    pass


                self.state = 599
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [39]:
                self.enterOuterAlt(localctx, 10)
                self.state = 601
                self.match(tradeQueryParser.RANDOM)
                self.state = 602
                self.match(tradeQueryParser.LPAREN)
                self.state = 614
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & -576465152497106976) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 478153715) != 0):
                    self.state = 605
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
                    if la_ == 1:
                        self.state = 603
                        self.expressionNumeric()
                        pass

                    elif la_ == 2:
                        self.state = 604
                        self.numericFunctionCall()
                        pass


                    self.state = 612
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==77:
                        self.state = 607
                        self.match(tradeQueryParser.COMMA)
                        self.state = 610
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                        if la_ == 1:
                            self.state = 608
                            self.expressionNumeric()
                            pass

                        elif la_ == 2:
                            self.state = 609
                            self.numericFunctionCall()
                            pass






                self.state = 616
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 11)
                self.state = 617
                self.match(tradeQueryParser.TONUMB)
                self.state = 618
                self.match(tradeQueryParser.LPAREN)
                self.state = 621
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                if la_ == 1:
                    self.state = 619
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 620
                    self.numericFunctionCall()
                    pass


                self.state = 623
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [43]:
                self.enterOuterAlt(localctx, 12)
                self.state = 625
                self.match(tradeQueryParser.DCOUNT)
                self.state = 626
                self.match(tradeQueryParser.LPAREN)
                self.state = 629
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 627
                    self.expressionNumeric()
                    pass

                elif la_ == 2:
                    self.state = 628
                    self.numericFunctionCall()
                    pass


                self.state = 631
                self.match(tradeQueryParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONCAT(self):
            return self.getToken(tradeQueryParser.CONCAT, 0)

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def expressionString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ExpressionStringContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ExpressionStringContext,i)


        def functionCall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.FunctionCallContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.FunctionCallContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.COMMA)
            else:
                return self.getToken(tradeQueryParser.COMMA, i)

        def REPLACE(self):
            return self.getToken(tradeQueryParser.REPLACE, 0)

        def UPPER(self):
            return self.getToken(tradeQueryParser.UPPER, 0)

        def LOWER(self):
            return self.getToken(tradeQueryParser.LOWER, 0)

        def CAPITALIZE(self):
            return self.getToken(tradeQueryParser.CAPITALIZE, 0)

        def TRIM(self):
            return self.getToken(tradeQueryParser.TRIM, 0)

        def RTRIM(self):
            return self.getToken(tradeQueryParser.RTRIM, 0)

        def LTRIM(self):
            return self.getToken(tradeQueryParser.LTRIM, 0)

        def SUBSTR(self):
            return self.getToken(tradeQueryParser.SUBSTR, 0)

        def LEN(self):
            return self.getToken(tradeQueryParser.LEN, 0)

        def TOSTRING(self):
            return self.getToken(tradeQueryParser.TOSTRING, 0)

        def MATCH(self):
            return self.getToken(tradeQueryParser.MATCH, 0)

        def URLENCODE(self):
            return self.getToken(tradeQueryParser.URLENCODE, 0)

        def URLDECODE(self):
            return self.getToken(tradeQueryParser.URLDECODE, 0)

        def DEFANG(self):
            return self.getToken(tradeQueryParser.DEFANG, 0)

        def TYPE(self):
            return self.getToken(tradeQueryParser.TYPE, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_stringFunctionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringFunctionCall" ):
                listener.enterStringFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringFunctionCall" ):
                listener.exitStringFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringFunctionCall" ):
                return visitor.visitStringFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def stringFunctionCall(self):

        localctx = tradeQueryParser.StringFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_stringFunctionCall)
        self._la = 0 # Token type
        try:
            self.state = 821
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [49]:
                self.enterOuterAlt(localctx, 1)
                self.state = 635
                self.match(tradeQueryParser.CONCAT)
                self.state = 636
                self.match(tradeQueryParser.LPAREN)
                self.state = 639
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                if la_ == 1:
                    self.state = 637
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 638
                    self.functionCall()
                    pass


                self.state = 648
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==77:
                    self.state = 641
                    self.match(tradeQueryParser.COMMA)
                    self.state = 644
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                    if la_ == 1:
                        self.state = 642
                        self.expressionString()
                        pass

                    elif la_ == 2:
                        self.state = 643
                        self.functionCall()
                        pass


                    self.state = 650
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 651
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 2)
                self.state = 653
                self.match(tradeQueryParser.REPLACE)
                self.state = 654
                self.match(tradeQueryParser.LPAREN)
                self.state = 657
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
                if la_ == 1:
                    self.state = 655
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 656
                    self.functionCall()
                    pass


                self.state = 659
                self.match(tradeQueryParser.COMMA)
                self.state = 662
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
                if la_ == 1:
                    self.state = 660
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 661
                    self.functionCall()
                    pass


                self.state = 664
                self.match(tradeQueryParser.COMMA)
                self.state = 667
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                if la_ == 1:
                    self.state = 665
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 666
                    self.functionCall()
                    pass


                self.state = 669
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 3)
                self.state = 671
                self.match(tradeQueryParser.UPPER)
                self.state = 672
                self.match(tradeQueryParser.LPAREN)
                self.state = 675
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                if la_ == 1:
                    self.state = 673
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 674
                    self.functionCall()
                    pass


                self.state = 677
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 4)
                self.state = 679
                self.match(tradeQueryParser.LOWER)
                self.state = 680
                self.match(tradeQueryParser.LPAREN)
                self.state = 683
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
                if la_ == 1:
                    self.state = 681
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 682
                    self.functionCall()
                    pass


                self.state = 685
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [53]:
                self.enterOuterAlt(localctx, 5)
                self.state = 687
                self.match(tradeQueryParser.CAPITALIZE)
                self.state = 688
                self.match(tradeQueryParser.LPAREN)
                self.state = 691
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
                if la_ == 1:
                    self.state = 689
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 690
                    self.functionCall()
                    pass


                self.state = 693
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 6)
                self.state = 695
                self.match(tradeQueryParser.TRIM)
                self.state = 696
                self.match(tradeQueryParser.LPAREN)
                self.state = 699
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
                if la_ == 1:
                    self.state = 697
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 698
                    self.functionCall()
                    pass


                self.state = 706
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==77:
                    self.state = 701
                    self.match(tradeQueryParser.COMMA)
                    self.state = 704
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
                    if la_ == 1:
                        self.state = 702
                        self.expressionString()
                        pass

                    elif la_ == 2:
                        self.state = 703
                        self.functionCall()
                        pass




                self.state = 708
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 7)
                self.state = 710
                self.match(tradeQueryParser.RTRIM)
                self.state = 711
                self.match(tradeQueryParser.LPAREN)
                self.state = 714
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
                if la_ == 1:
                    self.state = 712
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 713
                    self.functionCall()
                    pass


                self.state = 721
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==77:
                    self.state = 716
                    self.match(tradeQueryParser.COMMA)
                    self.state = 719
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
                    if la_ == 1:
                        self.state = 717
                        self.expressionString()
                        pass

                    elif la_ == 2:
                        self.state = 718
                        self.functionCall()
                        pass




                self.state = 723
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [54]:
                self.enterOuterAlt(localctx, 8)
                self.state = 725
                self.match(tradeQueryParser.LTRIM)
                self.state = 726
                self.match(tradeQueryParser.LPAREN)
                self.state = 729
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
                if la_ == 1:
                    self.state = 727
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 728
                    self.functionCall()
                    pass


                self.state = 736
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==77:
                    self.state = 731
                    self.match(tradeQueryParser.COMMA)
                    self.state = 734
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
                    if la_ == 1:
                        self.state = 732
                        self.expressionString()
                        pass

                    elif la_ == 2:
                        self.state = 733
                        self.functionCall()
                        pass




                self.state = 738
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 9)
                self.state = 740
                self.match(tradeQueryParser.SUBSTR)
                self.state = 741
                self.match(tradeQueryParser.LPAREN)
                self.state = 744
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
                if la_ == 1:
                    self.state = 742
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 743
                    self.functionCall()
                    pass


                self.state = 746
                self.match(tradeQueryParser.COMMA)
                self.state = 749
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
                if la_ == 1:
                    self.state = 747
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 748
                    self.functionCall()
                    pass


                self.state = 756
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==77:
                    self.state = 751
                    self.match(tradeQueryParser.COMMA)
                    self.state = 754
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
                    if la_ == 1:
                        self.state = 752
                        self.expressionString()
                        pass

                    elif la_ == 2:
                        self.state = 753
                        self.functionCall()
                        pass




                self.state = 758
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [48]:
                self.enterOuterAlt(localctx, 10)
                self.state = 760
                self.match(tradeQueryParser.LEN)
                self.state = 761
                self.match(tradeQueryParser.LPAREN)
                self.state = 764
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 762
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 763
                    self.functionCall()
                    pass


                self.state = 766
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 11)
                self.state = 768
                self.match(tradeQueryParser.TOSTRING)
                self.state = 769
                self.match(tradeQueryParser.LPAREN)
                self.state = 772
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
                if la_ == 1:
                    self.state = 770
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 771
                    self.functionCall()
                    pass


                self.state = 774
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [57]:
                self.enterOuterAlt(localctx, 12)
                self.state = 776
                self.match(tradeQueryParser.MATCH)
                self.state = 777
                self.match(tradeQueryParser.LPAREN)
                self.state = 780
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                if la_ == 1:
                    self.state = 778
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 779
                    self.functionCall()
                    pass


                self.state = 782
                self.match(tradeQueryParser.COMMA)
                self.state = 785
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
                if la_ == 1:
                    self.state = 783
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 784
                    self.functionCall()
                    pass


                self.state = 787
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 13)
                self.state = 789
                self.match(tradeQueryParser.URLENCODE)
                self.state = 790
                self.match(tradeQueryParser.LPAREN)
                self.state = 793
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
                if la_ == 1:
                    self.state = 791
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 792
                    self.functionCall()
                    pass


                self.state = 795
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [65]:
                self.enterOuterAlt(localctx, 14)
                self.state = 797
                self.match(tradeQueryParser.URLDECODE)
                self.state = 798
                self.match(tradeQueryParser.LPAREN)
                self.state = 801
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
                if la_ == 1:
                    self.state = 799
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 800
                    self.functionCall()
                    pass


                self.state = 803
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 15)
                self.state = 805
                self.match(tradeQueryParser.DEFANG)
                self.state = 806
                self.match(tradeQueryParser.LPAREN)
                self.state = 809
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
                if la_ == 1:
                    self.state = 807
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 808
                    self.functionCall()
                    pass


                self.state = 811
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [63]:
                self.enterOuterAlt(localctx, 16)
                self.state = 813
                self.match(tradeQueryParser.TYPE)
                self.state = 814
                self.match(tradeQueryParser.LPAREN)
                self.state = 817
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
                if la_ == 1:
                    self.state = 815
                    self.expressionString()
                    pass

                elif la_ == 2:
                    self.state = 816
                    self.functionCall()
                    pass


                self.state = 819
                self.match(tradeQueryParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpecificFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL(self):
            return self.getToken(tradeQueryParser.NULL, 0)

        def LPAREN(self):
            return self.getToken(tradeQueryParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(tradeQueryParser.RPAREN, 0)

        def ISNULL(self):
            return self.getToken(tradeQueryParser.ISNULL, 0)

        def expressionAny(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.ExpressionAnyContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.ExpressionAnyContext,i)


        def functionCall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.FunctionCallContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.FunctionCallContext,i)


        def ISNOTNULL(self):
            return self.getToken(tradeQueryParser.ISNOTNULL, 0)

        def TIME(self):
            return self.getToken(tradeQueryParser.TIME, 0)

        def TIMERANGE(self):
            return self.getToken(tradeQueryParser.TIMERANGE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(tradeQueryParser.COMMA)
            else:
                return self.getToken(tradeQueryParser.COMMA, i)

        def variableValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(tradeQueryParser.VariableValueContext)
            else:
                return self.getTypedRuleContext(tradeQueryParser.VariableValueContext,i)


        def FIELDSUMMARY(self):
            return self.getToken(tradeQueryParser.FIELDSUMMARY, 0)

        def COALESCE(self):
            return self.getToken(tradeQueryParser.COALESCE, 0)

        def MVJOIN(self):
            return self.getToken(tradeQueryParser.MVJOIN, 0)

        def MVINDEX(self):
            return self.getToken(tradeQueryParser.MVINDEX, 0)

        def MVEXPAND(self):
            return self.getToken(tradeQueryParser.MVEXPAND, 0)

        def VALUES(self):
            return self.getToken(tradeQueryParser.VALUES, 0)

        def AS(self):
            return self.getToken(tradeQueryParser.AS, 0)

        def stringValue(self):
            return self.getTypedRuleContext(tradeQueryParser.StringValueContext,0)


        def LATEST(self):
            return self.getToken(tradeQueryParser.LATEST, 0)

        def EARLIEST(self):
            return self.getToken(tradeQueryParser.EARLIEST, 0)

        def FIRST(self):
            return self.getToken(tradeQueryParser.FIRST, 0)

        def LAST(self):
            return self.getToken(tradeQueryParser.LAST, 0)

        def MACRO(self):
            return self.getToken(tradeQueryParser.MACRO, 0)

        def getRuleIndex(self):
            return tradeQueryParser.RULE_specificFunctionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecificFunctionCall" ):
                listener.enterSpecificFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecificFunctionCall" ):
                listener.exitSpecificFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecificFunctionCall" ):
                return visitor.visitSpecificFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def specificFunctionCall(self):

        localctx = tradeQueryParser.SpecificFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_specificFunctionCall)
        self._la = 0 # Token type
        try:
            self.state = 968
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 823
                self.match(tradeQueryParser.NULL)
                self.state = 824
                self.match(tradeQueryParser.LPAREN)
                self.state = 825
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 826
                self.match(tradeQueryParser.ISNULL)
                self.state = 827
                self.match(tradeQueryParser.LPAREN)
                self.state = 830
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                if la_ == 1:
                    self.state = 828
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 829
                    self.functionCall()
                    pass


                self.state = 832
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 3)
                self.state = 834
                self.match(tradeQueryParser.ISNOTNULL)
                self.state = 835
                self.match(tradeQueryParser.LPAREN)
                self.state = 838
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
                if la_ == 1:
                    self.state = 836
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 837
                    self.functionCall()
                    pass


                self.state = 840
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 4)
                self.state = 842
                self.match(tradeQueryParser.TIME)
                self.state = 843
                self.match(tradeQueryParser.LPAREN)
                self.state = 846
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 844
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 845
                    self.functionCall()
                    pass


                self.state = 848
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 5)
                self.state = 850
                self.match(tradeQueryParser.TIMERANGE)
                self.state = 851
                self.match(tradeQueryParser.LPAREN)
                self.state = 854
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
                if la_ == 1:
                    self.state = 852
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 853
                    self.functionCall()
                    pass


                self.state = 856
                self.match(tradeQueryParser.COMMA)
                self.state = 859
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                if la_ == 1:
                    self.state = 857
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 858
                    self.variableValue()
                    pass


                self.state = 861
                self.match(tradeQueryParser.COMMA)
                self.state = 862
                self.variableValue()
                self.state = 863
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 6)
                self.state = 865
                self.match(tradeQueryParser.FIELDSUMMARY)
                self.state = 866
                self.match(tradeQueryParser.LPAREN)
                self.state = 867
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [45]:
                self.enterOuterAlt(localctx, 7)
                self.state = 868
                self.match(tradeQueryParser.COALESCE)
                self.state = 869
                self.match(tradeQueryParser.LPAREN)
                self.state = 872
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
                if la_ == 1:
                    self.state = 870
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 871
                    self.functionCall()
                    pass


                self.state = 879 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 874
                    self.match(tradeQueryParser.COMMA)
                    self.state = 877
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
                    if la_ == 1:
                        self.state = 875
                        self.expressionAny()
                        pass

                    elif la_ == 2:
                        self.state = 876
                        self.functionCall()
                        pass


                    self.state = 881 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==77):
                        break

                self.state = 883
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [60]:
                self.enterOuterAlt(localctx, 8)
                self.state = 885
                self.match(tradeQueryParser.MVJOIN)
                self.state = 886
                self.match(tradeQueryParser.LPAREN)
                self.state = 889
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
                if la_ == 1:
                    self.state = 887
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 888
                    self.functionCall()
                    pass


                self.state = 896 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 891
                    self.match(tradeQueryParser.COMMA)
                    self.state = 894
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,125,self._ctx)
                    if la_ == 1:
                        self.state = 892
                        self.expressionAny()
                        pass

                    elif la_ == 2:
                        self.state = 893
                        self.functionCall()
                        pass


                    self.state = 898 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==77):
                        break

                self.state = 900
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [58]:
                self.enterOuterAlt(localctx, 9)
                self.state = 902
                self.match(tradeQueryParser.MVINDEX)
                self.state = 903
                self.match(tradeQueryParser.LPAREN)
                self.state = 906
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
                if la_ == 1:
                    self.state = 904
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 905
                    self.functionCall()
                    pass


                self.state = 908
                self.match(tradeQueryParser.COMMA)
                self.state = 911
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
                if la_ == 1:
                    self.state = 909
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 910
                    self.functionCall()
                    pass


                self.state = 913
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 10)
                self.state = 915
                self.match(tradeQueryParser.MVEXPAND)
                self.state = 916
                self.match(tradeQueryParser.LPAREN)
                self.state = 919
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                if la_ == 1:
                    self.state = 917
                    self.expressionAny()
                    pass

                elif la_ == 2:
                    self.state = 918
                    self.functionCall()
                    pass


                self.state = 921
                self.match(tradeQueryParser.RPAREN)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 11)
                self.state = 923
                self.match(tradeQueryParser.VALUES)
                self.state = 924
                self.match(tradeQueryParser.LPAREN)
                self.state = 925
                self.variableValue()
                self.state = 926
                self.match(tradeQueryParser.RPAREN)
                self.state = 929
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
                if la_ == 1:
                    self.state = 927
                    self.match(tradeQueryParser.AS)
                    self.state = 928
                    self.stringValue()


                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 12)
                self.state = 931
                self.match(tradeQueryParser.LATEST)
                self.state = 932
                self.match(tradeQueryParser.LPAREN)
                self.state = 933
                self.variableValue()
                self.state = 934
                self.match(tradeQueryParser.RPAREN)
                self.state = 937
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
                if la_ == 1:
                    self.state = 935
                    self.match(tradeQueryParser.AS)
                    self.state = 936
                    self.stringValue()


                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 13)
                self.state = 939
                self.match(tradeQueryParser.EARLIEST)
                self.state = 940
                self.match(tradeQueryParser.LPAREN)
                self.state = 941
                self.variableValue()
                self.state = 942
                self.match(tradeQueryParser.RPAREN)
                self.state = 945
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
                if la_ == 1:
                    self.state = 943
                    self.match(tradeQueryParser.AS)
                    self.state = 944
                    self.stringValue()


                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 14)
                self.state = 947
                self.match(tradeQueryParser.FIRST)
                self.state = 948
                self.match(tradeQueryParser.LPAREN)
                self.state = 949
                self.variableValue()
                self.state = 950
                self.match(tradeQueryParser.RPAREN)
                self.state = 953
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,133,self._ctx)
                if la_ == 1:
                    self.state = 951
                    self.match(tradeQueryParser.AS)
                    self.state = 952
                    self.stringValue()


                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 15)
                self.state = 955
                self.match(tradeQueryParser.LAST)
                self.state = 956
                self.match(tradeQueryParser.LPAREN)
                self.state = 957
                self.variableValue()
                self.state = 958
                self.match(tradeQueryParser.RPAREN)
                self.state = 961
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
                if la_ == 1:
                    self.state = 959
                    self.match(tradeQueryParser.AS)
                    self.state = 960
                    self.stringValue()


                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 16)
                self.state = 963
                self.match(tradeQueryParser.MACRO)
                self.state = 964
                self.match(tradeQueryParser.LPAREN)
                self.state = 965
                self.stringValue()
                self.state = 966
                self.match(tradeQueryParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[7] = self.arithmeticStringExpr_sempred
        self._predicates[10] = self.compareNumericExpr_sempred
        self._predicates[12] = self.termNumericResultOnlyExpr_sempred
        self._predicates[17] = self.arithmeticExpr_sempred
        self._predicates[18] = self.termExpr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def arithmeticStringExpr_sempred(self, localctx:ArithmeticStringExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def compareNumericExpr_sempred(self, localctx:CompareNumericExprContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

    def termNumericResultOnlyExpr_sempred(self, localctx:TermNumericResultOnlyExprContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

    def arithmeticExpr_sempred(self, localctx:ArithmeticExprContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         

    def termExpr_sempred(self, localctx:TermExprContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 2)
         




